"use strict";var A=Object.defineProperty;var I=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var K=Object.prototype.hasOwnProperty;var R=(t,r)=>{for(var o in r)A(t,o,{get:r[o],enumerable:!0})},k=(t,r,o,l)=>{if(r&&typeof r=="object"||typeof r=="function")for(let c of v(r))!K.call(t,c)&&c!==o&&A(t,c,{get:()=>r[c],enumerable:!(l=I(r,c))||l.enumerable});return t};var C=t=>k(A({},"__esModule",{value:!0}),t);var H={};R(H,{Address:()=>e,FUEL_BECH32_HRP_PREFIX:()=>d,addressify:()=>D,fromBech32:()=>h,getBytesFromBech32:()=>B,getRandomB256:()=>b,isB256:()=>u,isBech32:()=>i,isPublicKey:()=>p,normalizeBech32:()=>a,toB256:()=>g,toBech32:()=>m});module.exports=C(H);var n=require("@ethersproject/bytes"),x=require("@ethersproject/logger"),f=require("@fuel-ts/interfaces"),w=require("@fuel-ts/keystore"),S=require("@fuel-ts/versions"),s=require("bech32"),O=new x.Logger(S.versions.FUELS),d="fuel";function h(t){return s.bech32m.decode(t)}function m(t){return s.bech32m.encode(d,s.bech32m.toWords((0,n.arrayify)((0,n.hexlify)(t))))}function i(t){return typeof t=="string"&&t.indexOf(d+1)===0&&h(t).prefix===d}function u(t){return(t.length===66||t.length===64)&&/(0x)?[0-9a-f]{64}$/i.test(t)}function p(t){return(t.length===130||t.length===128)&&/(0x)?[0-9a-f]{128}$/i.test(t)}function B(t){return new Uint8Array(s.bech32m.fromWords(h(t).words))}function g(t){return i(t)||O.throwArgumentError("Invalid Bech32 Address","address",t),(0,n.hexlify)(B(t))}function a(t){let{words:r}=h(t);return s.bech32m.encode(d,r)}var D=t=>t instanceof f.AbstractAccount?t.address:t instanceof f.AbstractContract?t.id:t,b=()=>(0,n.hexlify)((0,w.randomBytes)(32));var L=require("@ethersproject/logger"),P=require("@ethersproject/sha2"),U=require("@fuel-ts/interfaces"),F=require("@fuel-ts/versions");var E=new L.Logger(F.versions.FUELS),e=class extends U.AbstractAddress{bech32Address;constructor(r){super(),E.checkNew(new.target,e),this.bech32Address=a(r),i(this.bech32Address)||E.throwArgumentError("Invalid Bech32 Address","address",r)}toAddress(){return this.bech32Address}toB256(){return g(this.bech32Address)}toBytes(){return B(this.bech32Address)}toHexString(){return this.toB256()}toString(){return this.bech32Address}toJSON(){return this.toString()}valueOf(){return this.toString()}equals(r){return this.bech32Address===r.bech32Address}static fromPublicKey(r){let o=(0,P.sha256)(r);return new e(m(o))}static fromB256(r){return new e(m(r))}static fromRandom(){return this.fromB256(b())}static fromString(r){return i(r)?new e(r):this.fromB256(r)}static fromAddressOrString(r){return typeof r=="string"?this.fromString(r):r}static fromDynamicInput(r){if(typeof r!="string"&&"toB256"in r)return e.fromB256(r.toB256());if(p(r))return e.fromPublicKey(r);if(i(r))return new e(r);if(u(r))return e.fromB256(r);throw new Error("Unknown address format: only Bech32, B256, or Public Key (512) supported")}};0&&(module.exports={Address,FUEL_BECH32_HRP_PREFIX,addressify,fromBech32,getBytesFromBech32,getRandomB256,isB256,isBech32,isPublicKey,normalizeBech32,toB256,toBech32});
//# sourceMappingURL=index.js.map