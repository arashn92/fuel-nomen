import{arrayify as l,hexlify as i}from"@ethersproject/bytes";import{Logger as y}from"@ethersproject/logger";import{AbstractContract as x,AbstractAccount as w}from"@fuel-ts/interfaces";import{randomBytes as S}from"@fuel-ts/keystore";import{versions as E}from"@fuel-ts/versions";import{bech32m as o}from"bech32";var L=new y(E.FUELS),n="fuel";function c(r){return o.decode(r)}function d(r){return o.encode(n,o.toWords(l(i(r))))}function s(r){return typeof r=="string"&&r.indexOf(n+1)===0&&c(r).prefix===n}function B(r){return(r.length===66||r.length===64)&&/(0x)?[0-9a-f]{64}$/i.test(r)}function A(r){return(r.length===130||r.length===128)&&/(0x)?[0-9a-f]{128}$/i.test(r)}function f(r){return new Uint8Array(o.fromWords(c(r).words))}function u(r){return s(r)||L.throwArgumentError("Invalid Bech32 Address","address",r),i(f(r))}function p(r){let{words:t}=c(r);return o.encode(n,t)}var D=r=>r instanceof w?r.address:r instanceof x?r.id:r,g=()=>i(S(32));import{Logger as P}from"@ethersproject/logger";import{sha256 as U}from"@ethersproject/sha2";import{AbstractAddress as F}from"@fuel-ts/interfaces";import{versions as I}from"@fuel-ts/versions";var a=new P(I.FUELS),e=class extends F{bech32Address;constructor(t){super(),a.checkNew(new.target,e),this.bech32Address=p(t),s(this.bech32Address)||a.throwArgumentError("Invalid Bech32 Address","address",t)}toAddress(){return this.bech32Address}toB256(){return u(this.bech32Address)}toBytes(){return f(this.bech32Address)}toHexString(){return this.toB256()}toString(){return this.bech32Address}toJSON(){return this.toString()}valueOf(){return this.toString()}equals(t){return this.bech32Address===t.bech32Address}static fromPublicKey(t){let b=U(t);return new e(d(b))}static fromB256(t){return new e(d(t))}static fromRandom(){return this.fromB256(g())}static fromString(t){return s(t)?new e(t):this.fromB256(t)}static fromAddressOrString(t){return typeof t=="string"?this.fromString(t):t}static fromDynamicInput(t){if(typeof t!="string"&&"toB256"in t)return e.fromB256(t.toB256());if(A(t))return e.fromPublicKey(t);if(s(t))return new e(t);if(B(t))return e.fromB256(t);throw new Error("Unknown address format: only Bech32, B256, or Public Key (512) supported")}};export{e as Address,n as FUEL_BECH32_HRP_PREFIX,D as addressify,c as fromBech32,f as getBytesFromBech32,g as getRandomB256,B as isB256,s as isBech32,A as isPublicKey,p as normalizeBech32,u as toB256,d as toBech32};
//# sourceMappingURL=index.mjs.map