"use strict";var ee=Object.defineProperty;var Be=Object.getOwnPropertyDescriptor;var ke=Object.getOwnPropertyNames;var $e=Object.prototype.hasOwnProperty;var _e=(s,e,t)=>e in s?ee(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var Ne=(s,e)=>{for(var t in e)ee(s,t,{get:e[t],enumerable:!0})},Me=(s,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of ke(e))!$e.call(s,n)&&n!==t&&ee(s,n,{get:()=>e[n],enumerable:!(r=Be(e,n))||r.enumerable});return s};var je=s=>Me(ee({},"__esModule",{value:!0}),s);var v=(s,e,t)=>(_e(s,typeof e!="symbol"?e+"":e,t),t),Te=(s,e,t)=>{if(!e.has(s))throw TypeError("Cannot "+t)};var R=(s,e,t)=>(Te(s,e,"read from private field"),t?t.call(s):e.get(s)),Z=(s,e,t)=>{if(e.has(s))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(s):e.set(s,t)},W=(s,e,t,r)=>(Te(s,e,"write to private field"),r?r.call(s,t):e.set(s,t),t);var ze={};Ne(ze,{ABI:()=>w,ASSET_ID_LEN:()=>Ft,AbiCoder:()=>O,ArrayCoder:()=>E,B256Coder:()=>V,B512Coder:()=>P,BYTES_32:()=>xt,BooleanCoder:()=>T,ByteCoder:()=>D,CONTRACT_ID_LEN:()=>Et,Coder:()=>d,EnumCoder:()=>A,Fragment:()=>H,FunctionFragment:()=>x,Interface:()=>F,MAX_INPUTS:()=>Ot,NumberCoder:()=>J,OPTION_CODER_TYPE:()=>q,StringCoder:()=>L,StructCoder:()=>U,TRANSACTION_SCRIPT_FIXED_SIZE:()=>It,TupleCoder:()=>C,U64Coder:()=>m,VEC_CODER_TYPE:()=>de,VM_TX_MEMORY:()=>wt,VecCoder:()=>b,WORD_SIZE:()=>Pe,arrayRegEx:()=>M,enumRegEx:()=>G,filterEmptyParams:()=>j,genericRegEx:()=>ce,getVectorAdjustments:()=>me,hasOptionTypes:()=>ue,isFlatJsonAbi:()=>ie,isReferenceType:()=>le,stringRegEx:()=>X,structRegEx:()=>K,tupleRegEx:()=>pe});module.exports=je(ze);var Ae=require("@ethersproject/logger"),Ce=require("@fuel-ts/versions"),ve=new Ae.Logger(Ce.versions.FUELS),d=class{name;type;encodedLength;offset;constructor(e,t,r){this.name=e,this.type=t,this.encodedLength=r}throwError(e,t){throw ve.throwArgumentError(e,this.name,t),new Error("unreachable")}setOffset(e){this.offset=e}};var xe=require("@ethersproject/bytes");var E=class extends d{coder;length;constructor(e,t){super("array",`[${e.type}; ${t}]`,t*e.encodedLength),this.coder=e,this.length=t}encode(e){return Array.isArray(e)||this.throwError("expected array value",e),this.length!==e.length&&this.throwError("Types/values length mismatch",e),(0,xe.concat)(Array.from(e).map(t=>this.coder.encode(t)))}decode(e,t){let r=t;return[Array(this.length).fill(0).map(()=>{let o;return[o,r]=this.coder.decode(e,r),o}),r]}};var Oe=require("@ethersproject/bytes"),te=require("@fuel-ts/math");var V=class extends d{constructor(){super("b256","b256",32)}encode(e){let t;try{t=(0,Oe.arrayify)(e)}catch{this.throwError(`Invalid ${this.type}`,e)}return t.length!==32&&this.throwError(`Invalid ${this.type}`,e),t}decode(e,t){let r=e.slice(t,t+32);return(0,te.bn)(r).isZero()&&(r=new Uint8Array(32)),r.length!==32&&this.throwError("Invalid size for b256",r),[(0,te.toHex)(r,32),t+32]}};var Fe=require("@ethersproject/bytes"),re=require("@fuel-ts/math");var P=class extends d{constructor(){super("b512","struct B512",64)}encode(e){let t;try{t=(0,Fe.arrayify)(e)}catch{this.throwError(`Invalid ${this.type}`,e)}return t.length!==64&&this.throwError(`Invalid ${this.type}`,e),t}decode(e,t){let r=e.slice(t,t+64);return(0,re.bn)(r).isZero()&&(r=new Uint8Array(64)),r.length!==64&&this.throwError("Invalid size for b512",r),[(0,re.toHex)(r,64),t+64]}};var k=require("@fuel-ts/math");var T=class extends d{constructor(){super("boolean","boolean",8)}encode(e){let t;try{t=(0,k.toBytes)(e?1:0)}catch{this.throwError("Invalid bool",e)}return t.length>1&&this.throwError("Invalid bool",e),(0,k.toBytes)(t,8)}decode(e,t){let r=(0,k.bn)(e.slice(t,t+8));return r.isZero()?[!1,t+8]:(r.eq((0,k.bn)(1))||this.throwError("Invalid boolean value",r),[!0,t+8])}};var $=require("@fuel-ts/math");var D=class extends d{constructor(){super("byte","byte",8)}encode(e){let t;try{t=(0,$.toBytes)(e,1)}catch{this.throwError("Invalid Byte",e)}return(0,$.toBytes)(t,8)}decode(e,t){let r=e.slice(t,t+8),n=(0,$.bn)(r);return n.gt((0,$.bn)(255))&&this.throwError("Invalid Byte",n),[Number(n),t+8]}};var Ee=require("@ethersproject/bytes"),we=require("@fuel-ts/math");var ne=require("@fuel-ts/math");var m=class extends d{constructor(){super("u64","u64",8)}encode(e){let t;try{t=(0,ne.toBytes)(e,8)}catch{this.throwError(`Invalid ${this.type}`,e)}return t}decode(e,t){let r=e.slice(t,t+8);return r=r.slice(0,8),[(0,ne.bn)(r),t+8]}};var Y,_,A=class extends d{constructor(t,r){let n=new m,o=Object.values(r).reduce((a,i)=>Math.max(a,i.encodedLength),0);super("enum",`enum ${t}`,n.encodedLength+o);v(this,"name");v(this,"coders");Z(this,Y,void 0);Z(this,_,void 0);this.name=t,this.coders=r,W(this,Y,n),W(this,_,o)}encode(t){let[r,...n]=Object.keys(t);if(!r)throw new Error("A field for the case must be provided");if(n.length!==0)throw new Error("Only one field must be provided");let o=this.coders[r],a=Object.keys(this.coders).indexOf(r),i=o.encode(t[r]),p=new Uint8Array(R(this,_)-o.encodedLength);return(0,Ee.concat)([R(this,Y).encode(a),p,i])}decode(t,r){let n=r,o;[o,n]=new m().decode(t,n);let a=(0,we.toNumber)(o),i=Object.keys(this.coders)[a];if(!i)throw new Error(`Invalid caseIndex "${a}". Valid cases: ${Object.keys(this.coders)}`);let p=this.coders[i];return n+=R(this,_)-p.encodedLength,[o,n]=p.decode(t,n),[{[i]:o},n]}};Y=new WeakMap,_=new WeakMap;var z=require("@fuel-ts/math");var J=class extends d{length;baseType;constructor(e){switch(super("number",e,8),this.baseType=e,e){case"u8":this.length=1;break;case"u16":this.length=2;break;case"u32":default:this.length=4;break}}encode(e){let t;try{t=(0,z.toBytes)(e)}catch{this.throwError(`Invalid ${this.baseType}`,e)}return t.length>this.length&&this.throwError(`Invalid ${this.baseType}. Too many bytes.`,e),(0,z.toBytes)(t,8)}decode(e,t){let r=e.slice(t,t+8);return r=r.slice(8-this.length,8),[(0,z.toNumber)(r),t+8]}};var Ie=require("@ethersproject/bytes"),oe=require("@ethersproject/strings");var N,L=class extends d{constructor(t){let r=(8-t)%8;r=r<0?r+8:r;super("string",`str[${t}]`,t+r);v(this,"length");Z(this,N,void 0);this.length=t,W(this,N,r)}encode(t){let r=(0,oe.toUtf8Bytes)(t.slice(0,this.length)),n=new Uint8Array(R(this,N));return(0,Ie.concat)([r,n])}decode(t,r){let n=t.slice(r,r+this.length),o=(0,oe.toUtf8String)(n),a=R(this,N);return[o,r+this.length+a]}};N=new WeakMap;var Re=require("@ethersproject/bytes");var S=class extends A{encode(e){return super.encode(this.toSwayOption(e))}toSwayOption(e){return e!==void 0?{Some:e}:{None:[]}}decode(e,t){let[r,n]=super.decode(e,t);return[this.toOption(r),n]}toOption(e){if(e&&"Some"in e)return e.Some}};var U=class extends d{name;coders;constructor(e,t){let r=Object.values(t).reduce((n,o)=>n+o.encodedLength,0);super("struct",`struct ${e}`,r),this.name=e,this.coders=t}encode(e){let t=Object.keys(this.coders).map(r=>{let n=this.coders[r],o=e[r];return!(n instanceof S)&&o==null&&this.throwError(`Invalid ${this.type}. Field "${r}" not present.`,e),n.encode(o)});return(0,Re.concat)(t)}decode(e,t){let r=t;return[Object.keys(this.coders).reduce((o,a)=>{let i=this.coders[a],p;return[p,r]=i.decode(e,r),o[a]=p,o},{}),r]}};var Ve=require("@ethersproject/bytes");var C=class extends d{coders;constructor(e){let t=e.reduce((r,n)=>r+n.encodedLength,0);super("tuple",`(${e.map(r=>r.type).join(", ")})`,t),this.coders=e}encode(e){return this.coders.length!==e.length&&this.throwError("Types/values length mismatch",{value:e}),(0,Ve.concat)(this.coders.map((t,r)=>t.encode(e[r])))}decode(e,t){let r=t;return[this.coders.map(o=>{let a;return[a,r]=o.decode(e,r),a}),r]}};var ye=require("@ethersproject/bytes");var q="enum Option",de="struct Vec",X=/str\[(?<length>[0-9]+)\]/,M=/\[(?<item>[\w\s\\[\]]+);\s*(?<length>[0-9]+)\]/,K=/^struct (?<name>\w+)$/,G=/^enum (?<name>\w+)$/,pe=/^\((?<items>.*)\)$/,ce=/^generic (?<name>\w+)$/,Pe=8,xt=32,Ot=255,Ft=32,Et=32,wt=10240,It=104;var Ze=3,b=class extends d{coder;constructor(e){super("struct","struct Vec",0),this.coder=e}static getBaseOffset(){return Ze*8}getEncodedVectorData(e){Array.isArray(e)||this.throwError("expected array value",e);let t=Array.from(e).map(r=>this.coder.encode(r));return(0,ye.concat)(t)}encode(e){Array.isArray(e)||this.throwError("expected array value",e);let t=[],r=this.offset||0;return t.push(new m().encode(r)),t.push(new m().encode(e.length)),t.push(new m().encode(e.length)),(0,ye.concat)(t)}decode(e,t){return this.throwError("unexpected Vec decode","not implemented"),[void 0,t]}};function j(s){return s.filter(e=>(e==null?void 0:e.type)!=="()"&&e!=="()")}function ue(s){return s.some(e=>(e==null?void 0:e.type)===q)}function me(s,e,t=0){let r=[],n=s.map((i,p)=>{if(!(i instanceof b))return{byteLength:i.encodedLength};let y=i.getEncodedVectorData(e[p]);return r.push(y),{vecByteLength:y.byteLength}}),o=r.length*b.getBaseOffset()+t,a=s.map((i,p)=>i instanceof b?n.reduce((y,l,B)=>"byteLength"in l?y+l.byteLength:B===0&&B===p?o:B<p?y+l.vecByteLength+o:y,0):0);return s.forEach((i,p)=>i.setOffset(a[p])),r}var H=class{type;name;inputs=[];outputs=[];attributes=[];constructor(e){this.type=e.type,this.name=e.name,this.inputs=e.inputs,this.outputs=e.outputs,this.attributes=e.attributes}};var De=require("@ethersproject/properties");function We(s,e){Object.keys(e).forEach(t=>{let r=t,n=e[r];(0,De.defineReadOnly)(s,r,n)})}var f=class{name;type;indexed;components;typeArguments;isParamType;constructor(e){We(this,e),this.isParamType=!0,Object.freeze(this)}getSignaturePrefix(){if(this.type){if(K.test(this.type))return"s";if(M.test(this.type))return"a";if(G.test(this.type))return"e"}return""}getSignatureContent(){var n,o;let e=this.type||"";if(e==="raw untyped ptr")return"rawptr";let t=(n=M.exec(e))==null?void 0:n.groups;if(t)return`[${this.components?this.components[0].getSighash():t.item};${t.length}]`;let r=(o=X.exec(e))==null?void 0:o.groups;if(r)return`str[${r.length}]`;if(Array.isArray(this.components)){let a=Array.isArray(this.typeArguments)?`<${this.typeArguments.map(p=>p.getSighash()).join(",")}>`:"",i=`(${this.components.map(p=>p.getSighash()).join(",")})`;return`${a}${i}`}return e}getSighash(){let e=this.getSignaturePrefix(),t=this.getSignatureContent();return`${e}${t}`}static fromObject(e){return f.isParamType(e)?e:new f({name:e.name,type:e.type,components:e.components?e.components.map(f.fromObject):void 0,typeArguments:e.typeArguments?e.typeArguments.map(f.fromObject):void 0})}static isParamType(e){return Boolean(e==null?void 0:e.isParamType)}};var x=class extends H{static fromObject(e){let{inputs:t=[],outputs:r=[],attributes:n=[]}=e,o={type:"function",name:e.name,inputs:t.map(f.fromObject),outputs:r.map(f.fromObject),attributes:n};return new x(o)}getInputsSighash(){let e=this.inputs.map(t=>t.getSighash());return`${this.name}(${e.join(",")})`}};var h=require("@ethersproject/bytes"),Le=require("@ethersproject/logger"),Se=require("@ethersproject/sha2"),fe=require("@ethersproject/strings"),Ue=require("@fuel-ts/versions");var Q=require("@ethersproject/bytes"),ae=require("@ethersproject/logger"),Je=require("@fuel-ts/versions");var se=new ae.Logger(Je.versions.FUELS),O=class{constructor(){se.checkNew(new.target,O)}getCoder(e){var i,p,y,l,B,he;switch(e.type){case"u8":case"u16":case"u32":return new J(e.type);case"u64":case"raw untyped ptr":return new m;case"bool":return new T;case"byte":return new D;case"b256":return new V;case"struct B512":return new P;default:}let t=(i=M.exec(e.type))==null?void 0:i.groups;if(t){let u=parseInt(t.length,10),g=(p=e.components)==null?void 0:p[0];if(!g)throw new Error("Expected array type to have an item component");let I=this.getCoder(g);return new E(I,u)}if(["raw untyped slice"].includes(e.type)){let g=this.getCoder({type:"u64"});return new E(g,0)}let r=(y=X.exec(e.type))==null?void 0:y.groups;if(r){let u=parseInt(r.length,10);return new L(u)}if(e.type===de&&Array.isArray(e.typeArguments)){let u=e.typeArguments[0];if(!u)throw new Error("Expected Vec type to have a type argument");let g=this.getCoder(u);return new b(g)}let n=(l=K.exec(e.type))==null?void 0:l.groups;if(n&&Array.isArray(e.components)){let u=e.components.reduce((g,I)=>(g[I.name]=this.getCoder(I),g),{});return new U(n.name,u)}let o=(B=G.exec(e.type))==null?void 0:B.groups;if(o&&Array.isArray(e.components)){let u=e.components.reduce((I,be)=>(I[be.name]=this.getCoder(be),I),{});return e.type===q?new S(o.name,u):new A(o.name,u)}if(((he=pe.exec(e.type))==null?void 0:he.groups)&&Array.isArray(e.components)){let u=e.components.map(g=>this.getCoder(g));return new C(u)}return se.throwArgumentError("Invalid type","type",e.type)}encode(e,t,r=0){let n=j(e),o=t.slice();Array.isArray(t)&&n.length!==t.length&&(ue(e)?(o.length=e.length,o.fill(void 0,t.length)):se.throwError("Types/values length mismatch during encode",ae.Logger.errors.INVALID_ARGUMENT,{count:{types:e.length,nonEmptyTypes:n.length,values:t.length},value:{types:e,nonEmptyTypes:n,values:t}}));let a=n.map(l=>this.getCoder(l)),i=me(a,o,r),y=new C(a).encode(o);return(0,Q.concat)([y,(0,Q.concat)(i)])}decode(e,t){let r=(0,Q.arrayify)(t),n=j(e),o=l=>{l!==r.length&&se.throwError("Types/values length mismatch during decode",ae.Logger.errors.INVALID_ARGUMENT,{count:{types:e.length,nonEmptyTypes:n.length,values:r.length,newOffset:l},value:{types:e,nonEmptyTypes:n,values:r}})};if(e.length===0||n.length===0){o(r.length?8:0);return}let a=n.map(l=>this.getCoder(l));n[0]&&n[0].type==="raw untyped slice"&&(a[0].length=r.length/8);let i=new C(a),[p,y]=i.decode(r,0);return o(y),p}};var ie=s=>!Array.isArray(s),w=class{types;functions;loggedTypes;constructor(e){this.types=e.types,this.functions=e.functions,this.loggedTypes=e.loggedTypes}parseLoggedType(e){return f.fromObject(this.parseInput(e.loggedType))}parseInput(e,t=new Map){let r=this.types[e.type],n,o;if(!r)throw new Error(`${e.type} not found`);if(Array.isArray(e.typeArguments)&&(o=e.typeArguments.map(a=>this.parseInput(a,t))),Array.isArray(r.typeParameters)&&Array.isArray(o)&&r.typeParameters.forEach((a,i)=>{o!=null&&o[i]&&t.set(a,o[i])}),Array.isArray(r.components)&&(n=r.components.map(a=>this.parseInput(a,t))),ce.test(r.type)){let a=t.get(r.typeId);if(a)return{...a,name:e.name}}return{type:r.type,name:e.name,typeArguments:o,components:n}}static unflatten(e){return ie(e)?new w(e).unflatten():e}unflattenLoggedTypes(){return this.loggedTypes.map(e=>({...e,abiFragmentType:[this.parseLoggedType(e)]}))}unflatten(){return this.functions.map(e=>({type:"function",name:e.name,inputs:(e.inputs||[]).map(t=>this.parseInput(t)),outputs:e.output?[this.parseInput(e.output)]:[],attributes:e.attributes||[]}))}},le=s=>{switch(s){case"u8":case"u16":case"u32":case"u64":case"bool":return!1;default:return!0}};var ge=new Le.Logger(Ue.versions.FUELS),Ye=s=>{let e=[];return s.forEach(t=>{t.type==="function"&&e.push(x.fromObject(t))}),e},F=class{fragments;functions;abiCoder;abi;types;loggedTypes;externalLoggedTypes;constructor(e){this.abi=ie(e)?new w(e):null,this.fragments=Ye(w.unflatten(e)),this.types=this.abi?this.abi.types:[],this.loggedTypes=this.abi?this.abi.unflattenLoggedTypes():[],this.externalLoggedTypes={},this.abiCoder=new O,this.functions={},this.fragments.forEach(t=>{let r={};switch(t.type){case"function":r=this.functions;break;default:return}let n=t.getInputsSighash();if(r[n]){ge.warn(`duplicate definition - ${n}`);return}r[n]=t})}static getSighash(e){let t=typeof e=="string"?(0,fe.toUtf8Bytes)(e):(0,fe.toUtf8Bytes)(e.getInputsSighash());return(0,h.concat)([new Uint8Array(4),(0,h.arrayify)((0,Se.sha256)(t)).slice(0,4)])}getFunction(e){if(this.functions[e])return this.functions[e];let t=Object.values(this.functions).find(r=>(0,h.hexlify)(F.getSighash(r))===e||r.name===e);return t||ge.throwArgumentError(`function ${e} not found.`,"data",t)}decodeFunctionData(e,t){let r=typeof e=="string"?this.getFunction(e):e,n=(0,h.arrayify)(t);return(0,h.hexlify)(n.slice(0,8))!==(0,h.hexlify)(F.getSighash(r))&&ge.throwArgumentError(`data signature does not match function ${r.name}.`,"data",(0,h.hexlify)(n)),this.abiCoder.decode(r.inputs,n.slice(16))}encodeFunctionData(e,t,r=0,n=!1){let o=typeof e=="string"?this.getFunction(e):e;if(!o)throw new Error("Fragment not found");let a=F.getSighash(o),i=j(o.inputs);if(i.length===0)return a;let p=this.abiCoder.encode(i,t,r);if(n)return p;let y=i.length>1||le(i[0].type);return(0,h.concat)([a,new T().encode(y),p])}decodeFunctionResult(e,t){let r=typeof e=="string"?this.getFunction(e):e,n=(0,h.arrayify)(t);return this.abiCoder.decode(r.outputs,n)}decodeLog(e,t,r){let o=(this.externalLoggedTypes[r]||this.loggedTypes).find(a=>a.logId===t);if(!(o!=null&&o.abiFragmentType))throw new Error(`Log ID - ${t} unknown`);return this.abiCoder.decode(o.abiFragmentType,e)}encodeFunctionResult(e,t){let r=typeof e=="string"?this.getFunction(e):e;if(!r)throw new Error("Fragment not found");return this.abiCoder.encode(r.outputs,t)}updateExternalLoggedTypes(e,t){this.externalLoggedTypes[e]=t}};0&&(module.exports={ABI,ASSET_ID_LEN,AbiCoder,ArrayCoder,B256Coder,B512Coder,BYTES_32,BooleanCoder,ByteCoder,CONTRACT_ID_LEN,Coder,EnumCoder,Fragment,FunctionFragment,Interface,MAX_INPUTS,NumberCoder,OPTION_CODER_TYPE,StringCoder,StructCoder,TRANSACTION_SCRIPT_FIXED_SIZE,TupleCoder,U64Coder,VEC_CODER_TYPE,VM_TX_MEMORY,VecCoder,WORD_SIZE,arrayRegEx,enumRegEx,filterEmptyParams,genericRegEx,getVectorAdjustments,hasOptionTypes,isFlatJsonAbi,isReferenceType,stringRegEx,structRegEx,tupleRegEx});
//# sourceMappingURL=index.js.map