var Gt=Object.defineProperty;var Ht=(s,t,e)=>t in s?Gt(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e;var a=(s,t,e)=>(Ht(s,typeof t!="symbol"?t+"":t,e),e);import Xt from"lodash.upperfirst";function ct(s){let e=[r=>r.replace(/\s+/g,"-"),r=>r.replace(/\./g,"-"),r=>r.replace(/_/g,"-"),r=>r.replace(/-[a-z]/g,i=>i.slice(-1).toUpperCase()),r=>r.replace(/-/g,""),r=>r.replace(/^\d+/,""),r=>Xt(r)].reduce((r,i)=>i(r),s);if(e==="")throw new Error(`Can't guess class name, please rename file: ${s}`);return e}function d(s){let{types:t,typeId:e}=s,r=t.find(({rawAbiType:{typeId:i}})=>i===e);if(!r)throw new Error(`Type ID not found: ${e}.`);return r.parseComponentsAttributes({types:t}),r}function A(s){let{types:t,typeArguments:e,parentTypeId:r,target:i}=s,c=`${i}Label`,n=[],m,u;r!==void 0&&(m=d({types:t,typeId:r}),u=m.attributes[c]),e.forEach(l=>{let T,I=l.type;try{T=d({types:t,typeId:I}).attributes[c]}catch{T="void"}if(l.typeArguments){let f=A({types:t,target:i,parentTypeId:l.type,typeArguments:l.typeArguments});n.push(f)}else n.push(`${T}`)});let y=n.join(", ");return u&&(y=`${u}<${y}>`),y}var j=class{name;types;rawAbiFunction;attributes;constructor(t){this.rawAbiFunction=t.rawAbiFunction,this.types=t.types,this.name=t.rawAbiFunction.name,this.attributes={inputs:this.bundleInputTypes(),output:this.bundleOutputTypes(),prefixedInputs:this.bundleInputTypes(!0)}}bundleInputTypes(t=!1){let{types:e}=this;return this.rawAbiFunction.inputs.map(i=>{let{name:c,type:n,typeArguments:m}=i,u=d({types:e,typeId:n}),y;return m?y=A({types:e,target:"input",parentTypeId:n,typeArguments:m}):y=u.attributes.inputLabel,t?`${c}: ${y}`:y}).join(", ")}bundleOutputTypes(){return A({types:this.types,target:"output",typeArguments:[this.rawAbiFunction.output]})}getDeclaration(){let{name:t}=this,{prefixedInputs:e,output:r}=this.attributes;return`${t}: InvokeFunction<[${e}], ${r}>`}};function mt(s){let{types:t,rawAbiFunction:e}=s;return new j({types:t,rawAbiFunction:e})}function ut(s){let{types:t,rawAbiFunctions:e}=s;return e.map(i=>mt({types:t,rawAbiFunction:i}))}var b=class{rawAbiType;attributes;requireImportFromFuels;constructor(t){this.rawAbiType=t.rawAbiType,this.attributes={inputLabel:"unknown",outputLabel:"unknown"},this.requireImportFromFuels=!1}};var q=class extends b{name="array";static isSuitableFor(t){return q.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){var y,l;let{types:e}=t,{type:r}=this.rawAbiType,i=Number((y=r.match(q.MATCH_REGEX))==null?void 0:y[1]),c=[],n=[];(l=this.rawAbiType.components)==null||l.forEach(T=>{let{type:I,typeArguments:f}=T;if(f){let x=A({types:e,typeArguments:f,parentTypeId:I,target:"input"}),Mt=A({types:e,typeArguments:f,parentTypeId:I,target:"output"});c.push(x),n.push(Mt)}else{let{attributes:x}=d({types:e,typeId:I});c.push(x.inputLabel),n.push(x.outputLabel)}});let m=Array(i).fill(c[0]).join(", "),u=Array(i).fill(n[0]).join(", ");return this.attributes={inputLabel:`[${m}]`,outputLabel:`[${u}]`},this.attributes}},E=q;a(E,"swayType","[_; 2]"),a(E,"MATCH_REGEX",/^\[_; ([0-9]+)\]$/m);var Y=class extends b{name="str";static isSuitableFor(t){return Y.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){return this.attributes={inputLabel:"string",outputLabel:"string"},this.attributes}},w=Y;a(w,"swayType","str[3]"),a(w,"MATCH_REGEX",/^str\[(.+)\]$/m);var Z=class extends w{name="b256";static isSuitableFor(t){return Z.MATCH_REGEX.test(t.type)}},R=Z;a(R,"swayType","b256"),a(R,"MATCH_REGEX",/^b256$/m);var tt=class extends R{name="b512";static isSuitableFor(t){return tt.MATCH_REGEX.test(t.type)}},_=tt;a(_,"swayType","struct B512"),a(_,"MATCH_REGEX",/^struct B512$/m);var et=class extends b{name="bool";static isSuitableFor(t){return et.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){return this.attributes={inputLabel:"boolean",outputLabel:"boolean"},this.attributes}},$=et;a($,"swayType","bool"),a($,"MATCH_REGEX",/^bool$/m);function L(s){var i;let{rawAbiType:t,regex:e}=s,r=(i=t.type.match(s.regex))==null?void 0:i[1];if(!r){let c=`Couldn't extract struct name with: '${e}'.

`;throw c+=`Check your JSON ABI.

[source]
`,c+=`${JSON.stringify(t,null,2)}`,new Error(c)}return r}var v=class extends b{name="enum";static isSuitableFor(t){let e=v.MATCH_REGEX.test(t.type),r=v.IGNORE_REGEX.test(t.type);return e&&!r}parseComponentsAttributes(t){let e=this.getStructName();return this.attributes={structName:e,inputLabel:`${e}Input`,outputLabel:`${e}Output`},this.attributes}getStructName(){return L({rawAbiType:this.rawAbiType,regex:v.MATCH_REGEX})}getStructContents(t){let{types:e,target:r}=t,{components:i}=this.rawAbiType,c=i,n=`${r}Label`;return c.map(u=>{let{name:y,type:l}=u;if(l===0)return`${y}: []`;let{attributes:T}=d({types:e,typeId:l});return`${y}: ${T[n]}`}).join(", ")}},C=v;a(C,"swayType","enum MyEnumName"),a(C,"MATCH_REGEX",/^enum (.+)$/m),a(C,"IGNORE_REGEX",/^enum Option$/m);var K=class extends b{name="generic";static isSuitableFor(t){return K.MATCH_REGEX.test(t.type)}getStructName(){return L({rawAbiType:this.rawAbiType,regex:K.MATCH_REGEX})}parseComponentsAttributes(t){let e=this.getStructName();return this.attributes={inputLabel:e,outputLabel:e},this.attributes}},O=K;a(O,"swayType","generic T"),a(O,"MATCH_REGEX",/^generic ([^\s]+)$/m);var rt=class extends b{name="option";static isSuitableFor(t){return rt.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){return this.attributes={inputLabel:"Option",outputLabel:"Option"},this.attributes}},M=rt;a(M,"swayType","enum Option"),a(M,"MATCH_REGEX",/^enum Option$/m);var it=class extends b{name="u8";constructor(t){super(t),this.attributes={inputLabel:"BigNumberish",outputLabel:"number"},this.requireImportFromFuels=!0}static isSuitableFor(t){return it.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){return this.attributes}},g=it;a(g,"swayType","u8"),a(g,"MATCH_REGEX",/^u8$/m);var nt=class extends g{name="u64";parseComponentsAttributes(t){return this.attributes={inputLabel:"BigNumberish",outputLabel:"BN"},this.attributes}static isSuitableFor(t){return nt.MATCH_REGEX.test(t.type)}},F=nt;a(F,"swayType","u64"),a(F,"MATCH_REGEX",/^u64$/m);var st=class extends F{name="rawUntypedPtr";static isSuitableFor(t){return st.MATCH_REGEX.test(t.type)}},G=st;a(G,"swayType","raw untyped ptr"),a(G,"MATCH_REGEX",/^raw untyped ptr$/m);var B=class extends b{name="struct";static isSuitableFor(t){let e=B.MATCH_REGEX.test(t.type),r=B.IGNORE_REGEX.test(t.type);return e&&!r}parseComponentsAttributes(t){let e=this.getStructName();return this.attributes={structName:e,inputLabel:`${e}Input`,outputLabel:`${e}Output`},this.attributes}getStructName(){return L({rawAbiType:this.rawAbiType,regex:B.MATCH_REGEX})}getStructContents(t){let{types:e,target:r}=t,{components:i}=this.rawAbiType;return i.map(m=>{let{name:u,type:y,typeArguments:l}=m,T=d({types:e,typeId:y}),I;if(l)I=A({types:e,target:r,parentTypeId:y,typeArguments:l});else{let f=`${r}Label`;I=T.attributes[f]}return`${u}: ${I}`}).join(", ")}getStructDeclaration(t){let{types:e}=t,{typeParameters:r}=this.rawAbiType;return r?`<${r.map(n=>d({types:e,typeId:n})).map(({attributes:{inputLabel:n}})=>n).join(", ")}>`:""}},N=B;a(N,"swayType","struct MyStruct"),a(N,"MATCH_REGEX",/^struct (.+)$/m),a(N,"IGNORE_REGEX",/^struct (Vec|RawVec)$/m);var ot=class extends b{name="tupple";static isSuitableFor(t){return ot.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){var c;let{types:e}=t,r=[],i=[];return(c=this.rawAbiType.components)==null||c.forEach(n=>{let{type:m,typeArguments:u}=n;if(u){let y=A({types:e,typeArguments:u,parentTypeId:m,target:"input"}),l=A({types:e,typeArguments:u,parentTypeId:m,target:"output"});r.push(y),i.push(l)}else{let{attributes:y}=d({types:e,typeId:m});r.push(y.inputLabel),i.push(y.outputLabel)}}),this.attributes={inputLabel:`[${r.join(", ")}]`,outputLabel:`[${i.join(", ")}]`},this.attributes}},H=ot;a(H,"swayType","(_, _, _)"),a(H,"MATCH_REGEX",/^\([_,\s]+\)$/m);var pt=class extends g{name="u16";static isSuitableFor(t){return pt.MATCH_REGEX.test(t.type)}},X=pt;a(X,"swayType","u16"),a(X,"MATCH_REGEX",/^u16$/m);var at=class extends g{name="u32";static isSuitableFor(t){return at.MATCH_REGEX.test(t.type)}},P=at;a(P,"swayType","u32"),a(P,"MATCH_REGEX",/^u32$/m);var Q=class extends E{name="vector";static isSuitableFor(t){let e=Q.MATCH_REGEX.test(t.type),r=Q.IGNORE_REGEX.test(t.type);return e&&!r}parseComponentsAttributes(t){return this.attributes={inputLabel:"Vec",outputLabel:"Vec"},this.attributes}},S=Q;a(S,"swayType","struct Vec"),a(S,"MATCH_REGEX",/^struct Vec/m),a(S,"IGNORE_REGEX",/^struct RawVec$/m);var yt=[E,R,_,$,C,O,M,G,w,N,H,X,P,F,g,S];function lt(s){let{rawAbiType:t}=s,{type:e}=t,r=yt.find(i=>i.isSuitableFor({type:e}));if(!r)throw new Error(`Type not supported: ${e}`);return new r(s)}function ft(s){return["()","struct RawVec"].indexOf(s.type)>=0}function bt(s){let t=[];return s.rawAbiTypes.forEach(e=>{let{type:r}=e;if(!ft({type:r})){let c=lt({rawAbiType:e});t.push(c)}}),t.forEach(e=>{e.parseComponentsAttributes({types:t})}),t}var W=class{name;programType;filepath;outputDir;commonTypesInUse=[];rawContents;hexlifiedBinContents;types;functions;constructor(t){let{filepath:e,outputDir:r,rawContents:i,hexlifiedBinContents:c,programType:n}=t,m=/([^/]+)-abi\.json$/m,u=e.match(m);if(!u||u.length===0)throw new Error(`Could not parse name from abi file: ${e}`);let l=`${ct(u[1])}Abi`;this.name=l,this.programType=n,this.filepath=e,this.rawContents=i,this.hexlifiedBinContents=c,this.outputDir=r;let{types:T,functions:I}=this.parse();this.types=T,this.functions=I,this.computeCommonTypesInUse()}parse(){let{types:t,functions:e}=this.rawContents,r=bt({rawAbiTypes:t}),i=ut({rawAbiFunctions:e,types:r});return{types:r,functions:i}}computeCommonTypesInUse(){let t={option:"Option",enum:"Enum",vector:"Vec"};this.commonTypesInUse=[],Object.keys(t).forEach(e=>{if(!!this.types.find(i=>i.name===e)){let i=t[e];this.commonTypesInUse.push(i)}})}};import{join as jt}from"path";import{versions as Ut}from"@fuel-ts/versions";import{compile as It}from"handlebars";var Tt=`/* Autogenerated file. Do not edit manually. */

/* tslint:disable */
/* eslint-disable */

/*
  Fuels version: {{FUELS}}
  Forc version: {{FORC}}
  Fuel-Core version: {{FUEL_CORE}}
*/
`;function h(s){let{data:t,template:e}=s,r={strict:!0,noEscape:!0},i=It(e,r),c=It(Tt,r);return i({...t,header:c(Ut)}).replace(/[\n]{3,}/gm,`

`)}var dt=`{{header}}

/*
  Mimics Sway Enum, requires at least one Key-Value but
  does not raise error on multiple pairs.
  This is done in the abi-coder
*/
export type Enum<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

/*
  Mimics Sway Option and Vectors.
  Vectors are treated like arrays in Typescript.
*/
export type Option<T> = T | undefined;

export type Vec<T> = T[];
`;function U(){return h({template:dt})}var At=`{{header}}

{{#if isGeneratingContracts}}
{{#each abis}}
export type { {{name}} } from './{{name}}';
{{/each}}
{{/if}}

{{#each abis}}
export { {{name}}__factory } from './factories/{{name}}__factory';
{{/each}}
`;function D(s){let{abis:t}=s,e=t[0].programType==="contract";return h({template:At,data:{abis:t,isGeneratingContracts:e}})}function V(s){let{types:t}=s;return{enums:t.filter(r=>r.name==="enum").map(r=>{let i=r,c=i.getStructName(),n=i.getStructContents({types:t,target:"input"}),m=i.getStructContents({types:t,target:"output"});return{structName:c,inputValues:n,outputValues:m,recycleRef:n===m}})}}import zt from"lodash.uniq";var kt=(s,t)=>s.toLowerCase().localeCompare(t.toLowerCase());function z(s){let{types:t,baseMembers:e=[]}=s,i=t.filter(n=>n.requireImportFromFuels).map(n=>n.attributes.inputLabel),c=zt(e.concat(i).sort(kt));return{imports:c.length?c:void 0}}function k(s){let{types:t}=s;return{structs:t.filter(r=>r.name==="struct").map(r=>{let i=r,c=i.getStructName(),n=i.getStructContents({types:t,target:"input"}),m=i.getStructContents({types:t,target:"output"}),u=i.getStructDeclaration({types:t});return{structName:c,typeAnnotations:u,inputValues:n,outputValues:m,recycleRef:n===m}})}}var ht=`{{header}}

{{#if imports}}
import type {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}

{{#each enums}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
{{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}


interface {{capitalizedName}}Interface extends Interface {
  functions: {
    {{#each functionsFragments}}
    {{this}}: FunctionFragment;
    {{/each}}
  };

  {{#each encoders}}
  encodeFunctionData(functionFragment: '{{functionName}}', values: [{{input}}]): Uint8Array;
  {{/each}}

  {{#each decoders}}
  decodeFunctionData(functionFragment: '{{functionName}}', data: BytesLike): DecodedValue;
  {{/each}}
}


export class {{capitalizedName}} extends Contract {
  interface: {{capitalizedName}}Interface;
  functions: {
    {{#each functionsTypedefs}}
    {{this}};
    {{/each}}
  };
}
`;function xt(s){let{name:t,types:e,functions:r,commonTypesInUse:i}=s.abi,c=r.map(f=>f.getDeclaration()),n=r.map(f=>f.name),m=r.map(f=>({functionName:f.name,input:f.attributes.inputs})),u=r.map(f=>({functionName:f.name})),{enums:y}=V({types:e}),{structs:l}=k({types:e}),{imports:T}=z({types:e,baseMembers:["Interface","FunctionFragment","DecodedValue","Contract","BytesLike","InvokeFunction","BN"]});return h({template:ht,data:{capitalizedName:t,commonTypesInUse:i.join(", "),functionsTypedefs:c,functionsFragments:n,encoders:m,decoders:u,structs:l,enums:y,imports:T}})}var Et=`{{header}}

import { Interface, Contract } from "fuels";
import type { Provider, Account, AbstractAddress } from "fuels";
import type { {{capitalizedName}}, {{capitalizedName}}Interface } from "../{{capitalizedName}}";

const _abi = {{abiJsonString}}

export class {{capitalizedName}}__factory {
  static readonly abi = _abi
  static createInterface(): {{capitalizedName}}Interface {
    return new Interface(_abi) as unknown as {{capitalizedName}}Interface
  }
  static connect(
    id: string | AbstractAddress,
    accountOrProvider: Account | Provider
  ): {{capitalizedName}} {
    return new Contract(id, _abi, accountOrProvider) as unknown as {{capitalizedName}}
  }
}
`;function wt(s){let{name:t,rawContents:e}=s.abi,r=JSON.stringify(e,null,2);return h({template:Et,data:{capitalizedName:t,abiJsonString:r}})}function Rt(s){let{abis:t,outputDir:e}=s,r=[],i=t.find(n=>n.commonTypesInUse.length>0);t.forEach(n=>{let{name:m}=n,u=`${e}/${m}.d.ts`,y=`${e}/factories/${m}__factory.ts`,l={path:u,contents:xt({abi:n})},T={path:y,contents:wt({abi:n})};r.push(l),r.push(T)});let c={path:`${e}/index.ts`,contents:D({abis:t})};if(r.push(c),i){let m={path:jt(e,"common.d.ts"),contents:U()};r.push(m)}return r}import{join as qt}from"path";var Ft=`{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
{{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

type {{capitalizedName}}Inputs = [{{inputs}}];

const _abi = {{abiJsonString}}

const _bin = '{{hexlifiedBinString}}'

export class {{capitalizedName}}__factory {

  static readonly abi = _abi
  static readonly bin = _bin;

  static createInstance(provider?: Provider) {

    const { abi, bin } = {{capitalizedName}}__factory

    const predicate = new Predicate(bin, abi, provider);

    return predicate;

  }

}
`;function Ct(s){let{abi:t}=s,{types:e}=t,{rawContents:r,name:i,hexlifiedBinContents:c}=s.abi,n=JSON.stringify(r,null,2),m=t.functions.find(x=>x.name==="main");if(!m)throw new Error("ABI doesn't have a 'main()' method.");let{enums:u}=V({types:e}),{structs:y}=k({types:e}),{imports:l}=z({types:e,baseMembers:["Predicate","Provider"]}),{prefixedInputs:T,output:I}=m.attributes;return h({template:Ft,data:{inputs:T,output:I,structs:y,enums:u,abiJsonString:n,hexlifiedBinString:c,capitalizedName:i,imports:l}})}function Nt(s){let{abis:t,outputDir:e}=s,r=[],i=t.find(n=>n.commonTypesInUse.length>0);t.forEach(n=>{let{name:m}=n,y={path:`${e}/factories/${m}__factory.ts`,contents:Ct({abi:n})};r.push(y)});let c={path:`${e}/index.ts`,contents:D({abis:t})};if(r.push(c),i){let m={path:qt(e,"common.d.ts"),contents:U()};r.push(m)}return r}import{join as Qt}from"path";var St=`{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
{{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

type {{capitalizedName}}Inputs = [{{inputs}}];
type {{capitalizedName}}Output = {{output}};

const _abi = {{abiJsonString}}

const _bin = '{{hexlifiedBinString}}'

export class {{capitalizedName}}__factory {

  static readonly abi = _abi
  static readonly bin = _bin

  static createInstance(wallet: Account) {

    const { abi, bin } = {{capitalizedName}}__factory

    const script = new Script<
      {{capitalizedName}}Inputs,
      {{capitalizedName}}Output
    >(bin, abi, wallet);

    return script;

  }

}
`;function _t(s){let{abi:t}=s,{types:e}=t,{rawContents:r,name:i,hexlifiedBinContents:c}=s.abi,n=JSON.stringify(r,null,2),m=t.functions.find(x=>x.name==="main");if(!m)throw new Error("ABI doesn't have a 'main()' method.");let{enums:u}=V({types:e}),{structs:y}=k({types:e}),{imports:l}=z({types:e,baseMembers:["Script","Account"]}),{prefixedInputs:T,output:I}=m.attributes;return h({template:St,data:{inputs:T,output:I,structs:y,enums:u,abiJsonString:n,hexlifiedBinString:c,capitalizedName:i,imports:l}})}function $t(s){let{abis:t,outputDir:e}=s,r=[],i=t.find(n=>n.commonTypesInUse.length>0);t.forEach(n=>{let{name:m}=n,y={path:`${e}/factories/${m}__factory.ts`,contents:_t({abi:n})};r.push(y)});let c={path:`${e}/index.ts`,contents:D({abis:t})};if(r.push(c),i){let m={path:Qt(e,"common.d.ts"),contents:U()};r.push(m)}return r}import Wt from"lodash.upperfirst";function Lt(s){let{abiFilepath:t,binFilepath:e,binExists:r,programType:i}=s,c=i==="script";if(!r&&c)throw new Error([`Could not find BIN file for counterpart ${Wt(i)} ABI.`,`  - ABI: ${t}`,`  - BIN: ${e}`,i].join(`
`))}var Ot=class{abis;abiFiles;binFiles;outputDir;files;constructor(t){let{abiFiles:e,binFiles:r,outputDir:i,programType:c}=t;this.outputDir=i,this.abiFiles=e,this.binFiles=r,this.abis=this.abiFiles.map(n=>{let m=n.path.replace("-abi.json",".bin"),u=this.binFiles.find(({path:l})=>l===m);return u||Lt({abiFilepath:n.path,binExists:!!u,binFilepath:m,programType:c}),new W({filepath:n.path,rawContents:JSON.parse(n.contents),hexlifiedBinContents:u==null?void 0:u.contents,outputDir:i,programType:c})}),this.files=this.getAssembledFiles({programType:c})}getAssembledFiles(t){let{abis:e,outputDir:r}=this,{programType:i}=t;switch(i){case"contract":return Rt({abis:e,outputDir:r});case"script":return $t({abis:e,outputDir:r});case"predicate":return Nt({abis:e,outputDir:r});default:throw new Error(`Invalid Typegen programType: ${i}`)}}};export{Ot as AbiTypeGen};
//# sourceMappingURL=index.mjs.map