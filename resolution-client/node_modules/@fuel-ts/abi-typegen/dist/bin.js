#!/usr/bin/env node
"use strict";var te=Object.create;var it=Object.defineProperty;var ee=Object.getOwnPropertyDescriptor;var re=Object.getOwnPropertyNames;var ne=Object.getPrototypeOf,ie=Object.prototype.hasOwnProperty;var se=(i,t,e)=>t in i?it(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var oe=(i,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of re(t))!ie.call(i,n)&&n!==e&&it(i,n,{get:()=>t[n],enumerable:!(r=ee(t,n))||r.enumerable});return i};var j=(i,t,e)=>(e=i!=null?te(ne(i)):{},oe(t||!i||!i.__esModule?it(e,"default",{value:i,enumerable:!0}):e,i));var p=(i,t,e)=>(se(i,typeof t!="symbol"?t+"":t,e),e);var Qt=require("@fuel-ts/versions"),k=require("commander");var kt=require("@ethersproject/bytes"),_=require("fs"),jt=require("glob"),Jt=j(require("mkdirp")),qt=require("path"),Kt=j(require("rimraf"));var dt=j(require("lodash.upperfirst"));function It(i){let e=[r=>r.replace(/\s+/g,"-"),r=>r.replace(/\./g,"-"),r=>r.replace(/_/g,"-"),r=>r.replace(/-[a-z]/g,n=>n.slice(-1).toUpperCase()),r=>r.replace(/-/g,""),r=>r.replace(/^\d+/,""),r=>(0,dt.default)(r)].reduce((r,n)=>n(r),i);if(e==="")throw new Error(`Can't guess class name, please rename file: ${i}`);return e}function I(i){let{types:t,typeId:e}=i,r=t.find(({rawAbiType:{typeId:n}})=>n===e);if(!r)throw new Error(`Type ID not found: ${e}.`);return r.parseComponentsAttributes({types:t}),r}function g(i){let{types:t,typeArguments:e,parentTypeId:r,target:n}=i,o=`${n}Label`,s=[],a,m;r!==void 0&&(a=I({types:t,typeId:r}),m=a.attributes[o]),e.forEach(y=>{let b,d=y.type;try{b=I({types:t,typeId:d}).attributes[o]}catch{b="void"}if(y.typeArguments){let l=g({types:t,target:n,parentTypeId:y.type,typeArguments:y.typeArguments});s.push(l)}else s.push(`${b}`)});let u=s.join(", ");return m&&(u=`${m}<${u}>`),u}var K=class{name;types;rawAbiFunction;attributes;constructor(t){this.rawAbiFunction=t.rawAbiFunction,this.types=t.types,this.name=t.rawAbiFunction.name,this.attributes={inputs:this.bundleInputTypes(),output:this.bundleOutputTypes(),prefixedInputs:this.bundleInputTypes(!0)}}bundleInputTypes(t=!1){let{types:e}=this;return this.rawAbiFunction.inputs.map(n=>{let{name:o,type:s,typeArguments:a}=n,m=I({types:e,typeId:s}),u;return a?u=g({types:e,target:"input",parentTypeId:s,typeArguments:a}):u=m.attributes.inputLabel,t?`${o}: ${u}`:u}).join(", ")}bundleOutputTypes(){return g({types:this.types,target:"output",typeArguments:[this.rawAbiFunction.output]})}getDeclaration(){let{name:t}=this,{prefixedInputs:e,output:r}=this.attributes;return`${t}: InvokeFunction<[${e}], ${r}>`}};function gt(i){let{types:t,rawAbiFunction:e}=i;return new K({types:t,rawAbiFunction:e})}function ht(i){let{types:t,rawAbiFunctions:e}=i;return e.map(n=>gt({types:t,rawAbiFunction:n}))}var T=class{rawAbiType;attributes;requireImportFromFuels;constructor(t){this.rawAbiType=t.rawAbiType,this.attributes={inputLabel:"unknown",outputLabel:"unknown"},this.requireImportFromFuels=!1}};var Q=class extends T{name="array";static isSuitableFor(t){return Q.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){var u,y;let{types:e}=t,{type:r}=this.rawAbiType,n=Number((u=r.match(Q.MATCH_REGEX))==null?void 0:u[1]),o=[],s=[];(y=this.rawAbiType.components)==null||y.forEach(b=>{let{type:d,typeArguments:l}=b;if(l){let f=g({types:e,typeArguments:l,parentTypeId:d,target:"input"}),x=g({types:e,typeArguments:l,parentTypeId:d,target:"output"});o.push(f),s.push(x)}else{let{attributes:f}=I({types:e,typeId:d});o.push(f.inputLabel),s.push(f.outputLabel)}});let a=Array(n).fill(o[0]).join(", "),m=Array(n).fill(s[0]).join(", ");return this.attributes={inputLabel:`[${a}]`,outputLabel:`[${m}]`},this.attributes}},E=Q;p(E,"swayType","[_; 2]"),p(E,"MATCH_REGEX",/^\[_; ([0-9]+)\]$/m);var st=class extends T{name="str";static isSuitableFor(t){return st.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){return this.attributes={inputLabel:"string",outputLabel:"string"},this.attributes}},w=st;p(w,"swayType","str[3]"),p(w,"MATCH_REGEX",/^str\[(.+)\]$/m);var ot=class extends w{name="b256";static isSuitableFor(t){return ot.MATCH_REGEX.test(t.type)}},F=ot;p(F,"swayType","b256"),p(F,"MATCH_REGEX",/^b256$/m);var pt=class extends F{name="b512";static isSuitableFor(t){return pt.MATCH_REGEX.test(t.type)}},$=pt;p($,"swayType","struct B512"),p($,"MATCH_REGEX",/^struct B512$/m);var at=class extends T{name="bool";static isSuitableFor(t){return at.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){return this.attributes={inputLabel:"boolean",outputLabel:"boolean"},this.attributes}},O=at;p(O,"swayType","bool"),p(O,"MATCH_REGEX",/^bool$/m);function L(i){var n;let{rawAbiType:t,regex:e}=i,r=(n=t.type.match(i.regex))==null?void 0:n[1];if(!r){let o=`Couldn't extract struct name with: '${e}'.

`;throw o+=`Check your JSON ABI.

[source]
`,o+=`${JSON.stringify(t,null,2)}`,new Error(o)}return r}var J=class extends T{name="enum";static isSuitableFor(t){let e=J.MATCH_REGEX.test(t.type),r=J.IGNORE_REGEX.test(t.type);return e&&!r}parseComponentsAttributes(t){let e=this.getStructName();return this.attributes={structName:e,inputLabel:`${e}Input`,outputLabel:`${e}Output`},this.attributes}getStructName(){return L({rawAbiType:this.rawAbiType,regex:J.MATCH_REGEX})}getStructContents(t){let{types:e,target:r}=t,{components:n}=this.rawAbiType,o=n,s=`${r}Label`;return o.map(m=>{let{name:u,type:y}=m;if(y===0)return`${u}: []`;let{attributes:b}=I({types:e,typeId:y});return`${u}: ${b[s]}`}).join(", ")}},C=J;p(C,"swayType","enum MyEnumName"),p(C,"MATCH_REGEX",/^enum (.+)$/m),p(C,"IGNORE_REGEX",/^enum Option$/m);var W=class extends T{name="generic";static isSuitableFor(t){return W.MATCH_REGEX.test(t.type)}getStructName(){return L({rawAbiType:this.rawAbiType,regex:W.MATCH_REGEX})}parseComponentsAttributes(t){let e=this.getStructName();return this.attributes={inputLabel:e,outputLabel:e},this.attributes}},G=W;p(G,"swayType","generic T"),p(G,"MATCH_REGEX",/^generic ([^\s]+)$/m);var ct=class extends T{name="option";static isSuitableFor(t){return ct.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){return this.attributes={inputLabel:"Option",outputLabel:"Option"},this.attributes}},P=ct;p(P,"swayType","enum Option"),p(P,"MATCH_REGEX",/^enum Option$/m);var mt=class extends T{name="u8";constructor(t){super(t),this.attributes={inputLabel:"BigNumberish",outputLabel:"number"},this.requireImportFromFuels=!0}static isSuitableFor(t){return mt.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){return this.attributes}},h=mt;p(h,"swayType","u8"),p(h,"MATCH_REGEX",/^u8$/m);var ut=class extends h{name="u64";parseComponentsAttributes(t){return this.attributes={inputLabel:"BigNumberish",outputLabel:"BN"},this.attributes}static isSuitableFor(t){return ut.MATCH_REGEX.test(t.type)}},R=ut;p(R,"swayType","u64"),p(R,"MATCH_REGEX",/^u64$/m);var yt=class extends R{name="rawUntypedPtr";static isSuitableFor(t){return yt.MATCH_REGEX.test(t.type)}},M=yt;p(M,"swayType","raw untyped ptr"),p(M,"MATCH_REGEX",/^raw untyped ptr$/m);var q=class extends T{name="struct";static isSuitableFor(t){let e=q.MATCH_REGEX.test(t.type),r=q.IGNORE_REGEX.test(t.type);return e&&!r}parseComponentsAttributes(t){let e=this.getStructName();return this.attributes={structName:e,inputLabel:`${e}Input`,outputLabel:`${e}Output`},this.attributes}getStructName(){return L({rawAbiType:this.rawAbiType,regex:q.MATCH_REGEX})}getStructContents(t){let{types:e,target:r}=t,{components:n}=this.rawAbiType;return n.map(a=>{let{name:m,type:u,typeArguments:y}=a,b=I({types:e,typeId:u}),d;if(y)d=g({types:e,target:r,parentTypeId:u,typeArguments:y});else{let l=`${r}Label`;d=b.attributes[l]}return`${m}: ${d}`}).join(", ")}getStructDeclaration(t){let{types:e}=t,{typeParameters:r}=this.rawAbiType;return r?`<${r.map(s=>I({types:e,typeId:s})).map(({attributes:{inputLabel:s}})=>s).join(", ")}>`:""}},N=q;p(N,"swayType","struct MyStruct"),p(N,"MATCH_REGEX",/^struct (.+)$/m),p(N,"IGNORE_REGEX",/^struct (Vec|RawVec)$/m);var lt=class extends T{name="tupple";static isSuitableFor(t){return lt.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){var o;let{types:e}=t,r=[],n=[];return(o=this.rawAbiType.components)==null||o.forEach(s=>{let{type:a,typeArguments:m}=s;if(m){let u=g({types:e,typeArguments:m,parentTypeId:a,target:"input"}),y=g({types:e,typeArguments:m,parentTypeId:a,target:"output"});r.push(u),n.push(y)}else{let{attributes:u}=I({types:e,typeId:a});r.push(u.inputLabel),n.push(u.outputLabel)}}),this.attributes={inputLabel:`[${r.join(", ")}]`,outputLabel:`[${n.join(", ")}]`},this.attributes}},H=lt;p(H,"swayType","(_, _, _)"),p(H,"MATCH_REGEX",/^\([_,\s]+\)$/m);var ft=class extends h{name="u16";static isSuitableFor(t){return ft.MATCH_REGEX.test(t.type)}},X=ft;p(X,"swayType","u16"),p(X,"MATCH_REGEX",/^u16$/m);var bt=class extends h{name="u32";static isSuitableFor(t){return bt.MATCH_REGEX.test(t.type)}},U=bt;p(U,"swayType","u32"),p(U,"MATCH_REGEX",/^u32$/m);var Z=class extends E{name="vector";static isSuitableFor(t){let e=Z.MATCH_REGEX.test(t.type),r=Z.IGNORE_REGEX.test(t.type);return e&&!r}parseComponentsAttributes(t){return this.attributes={inputLabel:"Vec",outputLabel:"Vec"},this.attributes}},S=Z;p(S,"swayType","struct Vec"),p(S,"MATCH_REGEX",/^struct Vec/m),p(S,"IGNORE_REGEX",/^struct RawVec$/m);var At=[E,F,$,O,C,G,P,M,w,N,H,X,U,R,h,S];function xt(i){let{rawAbiType:t}=i,{type:e}=t,r=At.find(n=>n.isSuitableFor({type:e}));if(!r)throw new Error(`Type not supported: ${e}`);return new r(i)}function Et(i){return["()","struct RawVec"].indexOf(i.type)>=0}function wt(i){let t=[];return i.rawAbiTypes.forEach(e=>{let{type:r}=e;if(!Et({type:r})){let o=xt({rawAbiType:e});t.push(o)}}),t.forEach(e=>{e.parseComponentsAttributes({types:t})}),t}var tt=class{name;programType;filepath;outputDir;commonTypesInUse=[];rawContents;hexlifiedBinContents;types;functions;constructor(t){let{filepath:e,outputDir:r,rawContents:n,hexlifiedBinContents:o,programType:s}=t,a=/([^/]+)-abi\.json$/m,m=e.match(a);if(!m||m.length===0)throw new Error(`Could not parse name from abi file: ${e}`);let y=`${It(m[1])}Abi`;this.name=y,this.programType=s,this.filepath=e,this.rawContents=n,this.hexlifiedBinContents=o,this.outputDir=r;let{types:b,functions:d}=this.parse();this.types=b,this.functions=d,this.computeCommonTypesInUse()}parse(){let{types:t,functions:e}=this.rawContents,r=wt({rawAbiTypes:t}),n=ht({rawAbiFunctions:e,types:r});return{types:r,functions:n}}computeCommonTypesInUse(){let t={option:"Option",enum:"Enum",vector:"Vec"};this.commonTypesInUse=[],Object.keys(t).forEach(e=>{if(!!this.types.find(n=>n.name===e)){let n=t[e];this.commonTypesInUse.push(n)}})}};var Gt=require("path");var Rt=require("@fuel-ts/versions"),Tt=require("handlebars");var Ft=`/* Autogenerated file. Do not edit manually. */

/* tslint:disable */
/* eslint-disable */

/*
  Fuels version: {{FUELS}}
  Forc version: {{FORC}}
  Fuel-Core version: {{FUEL_CORE}}
*/
`;function A(i){let{data:t,template:e}=i,r={strict:!0,noEscape:!0},n=(0,Tt.compile)(e,r),o=(0,Tt.compile)(Ft,r);return n({...t,header:o(Rt.versions)}).replace(/[\n]{3,}/gm,`

`)}var Ct=`{{header}}

/*
  Mimics Sway Enum, requires at least one Key-Value but
  does not raise error on multiple pairs.
  This is done in the abi-coder
*/
export type Enum<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

/*
  Mimics Sway Option and Vectors.
  Vectors are treated like arrays in Typescript.
*/
export type Option<T> = T | undefined;

export type Vec<T> = T[];
`;function v(){return A({template:Ct})}var Nt=`{{header}}

{{#if isGeneratingContracts}}
{{#each abis}}
export type { {{name}} } from './{{name}}';
{{/each}}
{{/if}}

{{#each abis}}
export { {{name}}__factory } from './factories/{{name}}__factory';
{{/each}}
`;function D(i){let{abis:t}=i,e=t[0].programType==="contract";return A({template:Nt,data:{abis:t,isGeneratingContracts:e}})}function V(i){let{types:t}=i;return{enums:t.filter(r=>r.name==="enum").map(r=>{let n=r,o=n.getStructName(),s=n.getStructContents({types:t,target:"input"}),a=n.getStructContents({types:t,target:"output"});return{structName:o,inputValues:s,outputValues:a,recycleRef:s===a}})}}var St=j(require("lodash.uniq")),me=(i,t)=>i.toLowerCase().localeCompare(t.toLowerCase());function z(i){let{types:t,baseMembers:e=[]}=i,n=t.filter(s=>s.requireImportFromFuels).map(s=>s.attributes.inputLabel),o=(0,St.default)(e.concat(n).sort(me));return{imports:o.length?o:void 0}}function B(i){let{types:t}=i;return{structs:t.filter(r=>r.name==="struct").map(r=>{let n=r,o=n.getStructName(),s=n.getStructContents({types:t,target:"input"}),a=n.getStructContents({types:t,target:"output"}),m=n.getStructDeclaration({types:t});return{structName:o,typeAnnotations:m,inputValues:s,outputValues:a,recycleRef:s===a}})}}var _t=`{{header}}

{{#if imports}}
import type {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}

{{#each enums}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
{{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}


interface {{capitalizedName}}Interface extends Interface {
  functions: {
    {{#each functionsFragments}}
    {{this}}: FunctionFragment;
    {{/each}}
  };

  {{#each encoders}}
  encodeFunctionData(functionFragment: '{{functionName}}', values: [{{input}}]): Uint8Array;
  {{/each}}

  {{#each decoders}}
  decodeFunctionData(functionFragment: '{{functionName}}', data: BytesLike): DecodedValue;
  {{/each}}
}


export class {{capitalizedName}} extends Contract {
  interface: {{capitalizedName}}Interface;
  functions: {
    {{#each functionsTypedefs}}
    {{this}};
    {{/each}}
  };
}
`;function $t(i){let{name:t,types:e,functions:r,commonTypesInUse:n}=i.abi,o=r.map(l=>l.getDeclaration()),s=r.map(l=>l.name),a=r.map(l=>({functionName:l.name,input:l.attributes.inputs})),m=r.map(l=>({functionName:l.name})),{enums:u}=V({types:e}),{structs:y}=B({types:e}),{imports:b}=z({types:e,baseMembers:["Interface","FunctionFragment","DecodedValue","Contract","BytesLike","InvokeFunction","BN"]});return A({template:_t,data:{capitalizedName:t,commonTypesInUse:n.join(", "),functionsTypedefs:o,functionsFragments:s,encoders:a,decoders:m,structs:y,enums:u,imports:b}})}var Ot=`{{header}}

import { Interface, Contract } from "fuels";
import type { Provider, Account, AbstractAddress } from "fuels";
import type { {{capitalizedName}}, {{capitalizedName}}Interface } from "../{{capitalizedName}}";

const _abi = {{abiJsonString}}

export class {{capitalizedName}}__factory {
  static readonly abi = _abi
  static createInterface(): {{capitalizedName}}Interface {
    return new Interface(_abi) as unknown as {{capitalizedName}}Interface
  }
  static connect(
    id: string | AbstractAddress,
    accountOrProvider: Account | Provider
  ): {{capitalizedName}} {
    return new Contract(id, _abi, accountOrProvider) as unknown as {{capitalizedName}}
  }
}
`;function Lt(i){let{name:t,rawContents:e}=i.abi,r=JSON.stringify(e,null,2);return A({template:Ot,data:{capitalizedName:t,abiJsonString:r}})}function Pt(i){let{abis:t,outputDir:e}=i,r=[],n=t.find(s=>s.commonTypesInUse.length>0);t.forEach(s=>{let{name:a}=s,m=`${e}/${a}.d.ts`,u=`${e}/factories/${a}__factory.ts`,y={path:m,contents:$t({abi:s})},b={path:u,contents:Lt({abi:s})};r.push(y),r.push(b)});let o={path:`${e}/index.ts`,contents:D({abis:t})};if(r.push(o),n){let a={path:(0,Gt.join)(e,"common.d.ts"),contents:v()};r.push(a)}return r}var Xt=require("path");var Mt=`{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
{{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

type {{capitalizedName}}Inputs = [{{inputs}}];

const _abi = {{abiJsonString}}

const _bin = '{{hexlifiedBinString}}'

export class {{capitalizedName}}__factory {

  static readonly abi = _abi
  static readonly bin = _bin;

  static createInstance(provider?: Provider) {

    const { abi, bin } = {{capitalizedName}}__factory

    const predicate = new Predicate(bin, abi, provider);

    return predicate;

  }

}
`;function Ht(i){let{abi:t}=i,{types:e}=t,{rawContents:r,name:n,hexlifiedBinContents:o}=i.abi,s=JSON.stringify(r,null,2),a=t.functions.find(f=>f.name==="main");if(!a)throw new Error("ABI doesn't have a 'main()' method.");let{enums:m}=V({types:e}),{structs:u}=B({types:e}),{imports:y}=z({types:e,baseMembers:["Predicate","Provider"]}),{prefixedInputs:b,output:d}=a.attributes;return A({template:Mt,data:{inputs:b,output:d,structs:u,enums:m,abiJsonString:s,hexlifiedBinString:o,capitalizedName:n,imports:y}})}function Ut(i){let{abis:t,outputDir:e}=i,r=[],n=t.find(s=>s.commonTypesInUse.length>0);t.forEach(s=>{let{name:a}=s,u={path:`${e}/factories/${a}__factory.ts`,contents:Ht({abi:s})};r.push(u)});let o={path:`${e}/index.ts`,contents:D({abis:t})};if(r.push(o),n){let a={path:(0,Xt.join)(e,"common.d.ts"),contents:v()};r.push(a)}return r}var Vt=require("path");var vt=`{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
{{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

type {{capitalizedName}}Inputs = [{{inputs}}];
type {{capitalizedName}}Output = {{output}};

const _abi = {{abiJsonString}}

const _bin = '{{hexlifiedBinString}}'

export class {{capitalizedName}}__factory {

  static readonly abi = _abi
  static readonly bin = _bin

  static createInstance(wallet: Account) {

    const { abi, bin } = {{capitalizedName}}__factory

    const script = new Script<
      {{capitalizedName}}Inputs,
      {{capitalizedName}}Output
    >(bin, abi, wallet);

    return script;

  }

}
`;function Dt(i){let{abi:t}=i,{types:e}=t,{rawContents:r,name:n,hexlifiedBinContents:o}=i.abi,s=JSON.stringify(r,null,2),a=t.functions.find(f=>f.name==="main");if(!a)throw new Error("ABI doesn't have a 'main()' method.");let{enums:m}=V({types:e}),{structs:u}=B({types:e}),{imports:y}=z({types:e,baseMembers:["Script","Account"]}),{prefixedInputs:b,output:d}=a.attributes;return A({template:vt,data:{inputs:b,output:d,structs:u,enums:m,abiJsonString:s,hexlifiedBinString:o,capitalizedName:n,imports:y}})}function zt(i){let{abis:t,outputDir:e}=i,r=[],n=t.find(s=>s.commonTypesInUse.length>0);t.forEach(s=>{let{name:a}=s,u={path:`${e}/factories/${a}__factory.ts`,contents:Dt({abi:s})};r.push(u)});let o={path:`${e}/index.ts`,contents:D({abis:t})};if(r.push(o),n){let a={path:(0,Vt.join)(e,"common.d.ts"),contents:v()};r.push(a)}return r}var Bt=j(require("lodash.upperfirst"));function rt(i){let{abiFilepath:t,binFilepath:e,binExists:r,programType:n}=i,o=n==="script";if(!r&&o)throw new Error([`Could not find BIN file for counterpart ${(0,Bt.default)(n)} ABI.`,`  - ABI: ${t}`,`  - BIN: ${e}`,n].join(`
`))}var nt=class{abis;abiFiles;binFiles;outputDir;files;constructor(t){let{abiFiles:e,binFiles:r,outputDir:n,programType:o}=t;this.outputDir=n,this.abiFiles=e,this.binFiles=r,this.abis=this.abiFiles.map(s=>{let a=s.path.replace("-abi.json",".bin"),m=this.binFiles.find(({path:y})=>y===a);return m||rt({abiFilepath:s.path,binExists:!!m,binFilepath:a,programType:o}),new tt({filepath:s.path,rawContents:JSON.parse(s.contents),hexlifiedBinContents:m==null?void 0:m.contents,outputDir:n,programType:o})}),this.files=this.getAssembledFiles({programType:o})}getAssembledFiles(t){let{abis:e,outputDir:r}=this,{programType:n}=t;switch(n){case"contract":return Pt({abis:e,outputDir:r});case"script":return zt({abis:e,outputDir:r});case"predicate":return Ut({abis:e,outputDir:r});default:throw new Error(`Invalid Typegen programType: ${n}`)}}};function Yt(i){let{cwd:t,inputs:e,output:r,silent:n,programType:o,filepaths:s}=i,a=(0,qt.basename)(t),{log:m}=console;n&&(m=()=>({}));let u=[];if(!(s!=null&&s.length)&&(e==null?void 0:e.length))u=e.flatMap(f=>(0,jt.sync)(f,{cwd:t}));else if(s!=null&&s.length)u=s;else throw new Error("You need to inform at least one parameter: `input` or `filepaths`");let y=u.map(f=>({path:f,contents:(0,_.readFileSync)(f,"utf-8")})),d=o==="script"?u.map(f=>{let x=f.replace("-abi.json",".bin"),Zt=(0,_.existsSync)(x);return rt({abiFilepath:f,binFilepath:x,binExists:Zt,programType:o}),{path:x,contents:(0,kt.hexlify)((0,_.readFileSync)(x))}}):[],l=new nt({outputDir:r,abiFiles:y,binFiles:d,programType:o});m(`Generating files..
`),Jt.default.sync(`${r}/factories`),l.files.forEach(f=>{Kt.default.sync(f.path),(0,_.writeFileSync)(f.path,f.contents);let x=new RegExp(`^.+${a}/`,"m");m(` - ${f.path.replace(x,"")}`)}),m(`
Done.\u26A1`)}function be(i){let{contract:t,script:e,predicate:r}=i;return t||!t&&!e&&!r?"contract":r?"predicate":"script"}function Te(i){let{inputs:t,output:e,silent:r,contract:n,script:o,predicate:s}=i,a=process.cwd(),m=be({contract:n,script:o,predicate:s});Yt({cwd:a,inputs:t,output:e,programType:m,silent:!!r})}function de(i){i.requiredOption("-i, --inputs <path|glob...>","input paths/globals to your abi json files").requiredOption("-o, --output <dir>","directory path for generated files").addOption(new k.Option("-c, --contract","generate types for Contracts [default]").conflicts(["script","predicate"]).implies({script:void 0,predicate:void 0})).addOption(new k.Option("-s, --script","generate types for Scripts").conflicts(["contract","predicate"]).implies({contract:void 0,predicate:void 0})).addOption(new k.Option("-p, --predicate","generate types for Predicates").conflicts(["contract","script"]).implies({contract:void 0,script:void 0})).option("-S, --silent","omit output messages").action(Te)}function Wt(i){let t=new k.Command,{argv:e,programName:r}=i;t.name(r),t.version(Qt.versions.FUELS),t.usage("-i ../out/*-abi.json -o ./generated/"),de(t),t.parse(e)}Wt({argv:process.argv,programName:"fuels-typegen"});
//# sourceMappingURL=bin.js.map