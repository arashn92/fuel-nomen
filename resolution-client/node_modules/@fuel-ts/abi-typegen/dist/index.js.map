{"version":3,"sources":["../src/index.ts","../src/utils/normalize.ts","../src/utils/findType.ts","../src/utils/parseTypeArguments.ts","../src/abi/functions/Function.ts","../src/utils/makeFunction.ts","../src/utils/parseFunctions.ts","../src/abi/types/AType.ts","../src/abi/types/ArrayType.ts","../src/abi/types/StrType.ts","../src/abi/types/B256Type.ts","../src/abi/types/B512Type.ts","../src/abi/types/BoolType.ts","../src/utils/extractStructName.ts","../src/abi/types/EnumType.ts","../src/abi/types/GenericType.ts","../src/abi/types/OptionType.ts","../src/abi/types/U8Type.ts","../src/abi/types/U64Type.ts","../src/abi/types/RawUntypedPtr.ts","../src/abi/types/StructType.ts","../src/abi/types/TupleType.ts","../src/abi/types/U16Type.ts","../src/abi/types/U32Type.ts","../src/abi/types/VectorType.ts","../src/utils/supportedTypes.ts","../src/utils/makeType.ts","../src/utils/shouldSkipAbiType.ts","../src/utils/parseTypes.ts","../src/abi/Abi.ts","../src/utils/assembleContracts.ts","../src/templates/renderHbsTemplate.ts","../src/templates/common/common.ts","../src/templates/common/index.ts","../src/templates/utils/formatEnums.ts","../src/templates/utils/formatImports.ts","../src/templates/utils/formatStructs.ts","../src/templates/contract/dts.ts","../src/templates/contract/factory.ts","../src/utils/assemblePredicates.ts","../src/templates/predicate/factory.ts","../src/utils/assembleScripts.ts","../src/templates/script/factory.ts","../src/utils/validateBinFile.ts","../src/AbiTypeGen.ts"],"sourcesContent":["export * from './AbiTypeGen';\n\nexport * from './types/interfaces/IFile';\nexport * from './types/interfaces/IFunction';\nexport * from './types/interfaces/IRawAbi';\nexport * from './types/interfaces/IRawAbiFunction';\nexport * from './types/interfaces/IRawAbiType';\nexport * from './types/interfaces/IRawAbiLoggedTypes';\n","import upperFirst from 'lodash.upperfirst';\n\n/**\n * Converts valid file names to valid javascript symbols and does\n * best effort to make them readable.\n *\n * Example: ds-token.test becomes DsTokenTest\n */\nexport function normalizeName(rawName: string): string {\n  const transformations: ((s: string) => string)[] = [\n    (s) => s.replace(/\\s+/g, '-'), // spaces to -\n    (s) => s.replace(/\\./g, '-'), // dots to -\n    (s) => s.replace(/_/g, '-'), // underscore to -\n    (s) => s.replace(/-[a-z]/g, (match) => match.slice(-1).toUpperCase()), // delete '-' and capitalize the letter after them\n    (s) => s.replace(/-/g, ''), // delete any '-' left\n    (s) => s.replace(/^\\d+/, ''), // removes leading digits\n    (s) => upperFirst(s),\n  ];\n\n  const finalName = transformations.reduce((s, t) => t(s), rawName);\n\n  if (finalName === '') {\n    throw new Error(`Can't guess class name, please rename file: ${rawName}`);\n  }\n\n  return finalName;\n}\n","import type { IType } from '../types/interfaces/IType';\n\nexport function findType(params: { types: IType[]; typeId: number }) {\n  const { types, typeId } = params;\n\n  const foundType = types.find(({ rawAbiType: { typeId: tid } }) => tid === typeId);\n\n  if (!foundType) {\n    throw new Error(`Type ID not found: ${typeId}.`);\n  }\n\n  // ensure type attributes is always parsed\n  foundType.parseComponentsAttributes({ types });\n\n  return foundType;\n}\n","import type { TargetEnum } from '../types/enums/TargetEnum';\nimport type { IRawAbiTypeComponent } from '../types/interfaces/IRawAbiType';\nimport type { IType } from '../types/interfaces/IType';\n\nimport { findType } from './findType';\n\n/*\n  Recursively parses the given `typeArguments` node\n*/\nexport function parseTypeArguments(params: {\n  types: IType[];\n  target: TargetEnum;\n  typeArguments: IRawAbiTypeComponent[];\n  parentTypeId?: number;\n}): string {\n  const { types, typeArguments, parentTypeId, target } = params;\n\n  const attributeKey: 'inputLabel' | 'outputLabel' = `${target}Label`;\n\n  const buffer: string[] = [];\n\n  let parentType: IType | undefined;\n  let parentLabel: string | undefined;\n\n  if (parentTypeId !== undefined) {\n    parentType = findType({ types, typeId: parentTypeId });\n    parentLabel = parentType.attributes[attributeKey];\n  }\n\n  // loop through all `typeArgument` items\n  typeArguments.forEach((typeArgument) => {\n    let currentLabel: string;\n\n    const currentTypeId = typeArgument.type;\n\n    try {\n      const currentType = findType({ types, typeId: currentTypeId });\n      currentLabel = currentType.attributes[attributeKey];\n    } catch (_err) {\n      // used for functions without output\n      currentLabel = 'void';\n    }\n\n    if (typeArgument.typeArguments) {\n      // recursively process nested `typeArguments`\n      const nestedParsed = parseTypeArguments({\n        types,\n        target,\n        parentTypeId: typeArgument.type,\n        typeArguments: typeArgument.typeArguments,\n      });\n\n      buffer.push(nestedParsed);\n    } else {\n      buffer.push(`${currentLabel}`);\n    }\n  });\n\n  let output = buffer.join(', ');\n\n  if (parentLabel) {\n    output = `${parentLabel}<${output}>`;\n  }\n\n  return output;\n}\n","import type { IFunction, IRawAbiFunction, IFunctionAttributes } from '../../index';\nimport { TargetEnum } from '../../types/enums/TargetEnum';\nimport type { IType } from '../../types/interfaces/IType';\nimport { findType } from '../../utils/findType';\nimport { parseTypeArguments } from '../../utils/parseTypeArguments';\n\nexport class Function implements IFunction {\n  public name: string;\n  public types: IType[];\n  public rawAbiFunction: IRawAbiFunction;\n  public attributes: IFunctionAttributes;\n\n  constructor(params: { types: IType[]; rawAbiFunction: IRawAbiFunction }) {\n    this.rawAbiFunction = params.rawAbiFunction;\n    this.types = params.types;\n    this.name = params.rawAbiFunction.name;\n\n    this.attributes = {\n      inputs: this.bundleInputTypes(),\n      output: this.bundleOutputTypes(),\n      prefixedInputs: this.bundleInputTypes(true),\n    };\n  }\n\n  bundleInputTypes(shouldPrefixParams: boolean = false) {\n    const { types } = this;\n\n    // loop through all inputs\n    const inputs = this.rawAbiFunction.inputs.map((input) => {\n      const { name, type: typeId, typeArguments } = input;\n\n      const type = findType({ types, typeId });\n\n      let typeDecl: string;\n\n      if (typeArguments) {\n        // recursively process child `typeArguments`\n        typeDecl = parseTypeArguments({\n          types,\n          target: TargetEnum.INPUT,\n          parentTypeId: typeId,\n          typeArguments,\n        });\n      } else {\n        // or just collect type declaration\n        typeDecl = type.attributes.inputLabel;\n      }\n\n      // assemble it in `[key: string]: <Type>` fashion\n      if (shouldPrefixParams) {\n        return `${name}: ${typeDecl}`;\n      }\n\n      return typeDecl;\n    });\n\n    return inputs.join(', ');\n  }\n\n  bundleOutputTypes() {\n    return parseTypeArguments({\n      types: this.types,\n      target: TargetEnum.OUTPUT,\n      typeArguments: [this.rawAbiFunction.output],\n    });\n  }\n\n  getDeclaration() {\n    const { name } = this;\n    const { prefixedInputs, output } = this.attributes;\n    const decl = `${name}: InvokeFunction<[${prefixedInputs}], ${output}>`;\n    return decl;\n  }\n}\n","import { Function } from '../abi/functions/Function';\nimport type { IRawAbiFunction } from '../types/interfaces/IRawAbiFunction';\nimport type { IType } from '../types/interfaces/IType';\n\nexport function makeFunction(params: { types: IType[]; rawAbiFunction: IRawAbiFunction }) {\n  const { types, rawAbiFunction } = params;\n  return new Function({ types, rawAbiFunction });\n}\n","import type { IFunction } from '../types/interfaces/IFunction';\nimport type { IRawAbiFunction } from '../types/interfaces/IRawAbiFunction';\nimport type { IType } from '../types/interfaces/IType';\n\nimport { makeFunction } from './makeFunction';\n\nexport function parseFunctions(params: { types: IType[]; rawAbiFunctions: IRawAbiFunction[] }) {\n  const { types, rawAbiFunctions } = params;\n  const functions: IFunction[] = rawAbiFunctions.map((rawAbiFunction) =>\n    makeFunction({ types, rawAbiFunction })\n  );\n  return functions;\n}\n","import type { IRawAbiTypeRoot } from '../../types/interfaces/IRawAbiType';\nimport type { ITypeAttributes } from '../../types/interfaces/IType';\n\nexport class AType {\n  public rawAbiType: IRawAbiTypeRoot;\n  public attributes: ITypeAttributes;\n  public requireImportFromFuels?: boolean;\n\n  constructor(params: { rawAbiType: IRawAbiTypeRoot }) {\n    this.rawAbiType = params.rawAbiType;\n    this.attributes = {\n      inputLabel: 'unknown',\n      outputLabel: 'unknown',\n    };\n    this.requireImportFromFuels = false;\n  }\n}\n","import { TargetEnum } from '../../types/enums/TargetEnum';\nimport type { IType } from '../../types/interfaces/IType';\nimport { findType } from '../../utils/findType';\nimport { parseTypeArguments } from '../../utils/parseTypeArguments';\n\nimport { AType } from './AType';\n\nexport class ArrayType extends AType implements IType {\n  // Note: the array length expressed in '; 2]' could be any length\n  public static swayType = '[_; 2]';\n\n  public name = 'array';\n\n  static MATCH_REGEX: RegExp = /^\\[_; ([0-9]+)\\]$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return ArrayType.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(params: { types: IType[] }) {\n    const { types } = params;\n    const { type } = this.rawAbiType;\n\n    // array length will be used to generated a fixed-length array type\n    const arrayLen = Number(type.match(ArrayType.MATCH_REGEX)?.[1]);\n\n    const inputs: string[] = [];\n    const outputs: string[] = [];\n\n    this.rawAbiType.components?.forEach((component) => {\n      const { type: typeId, typeArguments } = component;\n\n      if (!typeArguments) {\n        // if component has no type arguments, read its attributes and voilà\n        const { attributes } = findType({ types, typeId });\n\n        inputs.push(attributes.inputLabel);\n        outputs.push(attributes.outputLabel);\n      } else {\n        // otherwise process child `typeArguments` recursively\n        const inputLabel = parseTypeArguments({\n          types,\n          typeArguments,\n          parentTypeId: typeId,\n          target: TargetEnum.INPUT,\n        });\n\n        const outputLabel = parseTypeArguments({\n          types,\n          typeArguments,\n          parentTypeId: typeId,\n          target: TargetEnum.OUTPUT,\n        });\n\n        inputs.push(inputLabel);\n        outputs.push(outputLabel);\n      }\n    });\n\n    // fixed-length array, based on `arrayLen`\n    const inputTypes = Array(arrayLen).fill(inputs[0]).join(', ');\n    const outputTypes = Array(arrayLen).fill(outputs[0]).join(', ');\n\n    this.attributes = {\n      inputLabel: `[${inputTypes}]`,\n      outputLabel: `[${outputTypes}]`,\n    };\n\n    return this.attributes;\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { AType } from './AType';\n\nexport class StrType extends AType implements IType {\n  // Note: the str length expressed in '[3]' could be any length\n  public static swayType = 'str[3]';\n\n  public name = 'str';\n\n  static MATCH_REGEX: RegExp = /^str\\[(.+)\\]$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return StrType.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    this.attributes = {\n      inputLabel: 'string',\n      outputLabel: 'string',\n    };\n    return this.attributes;\n  }\n}\n","import { StrType } from './StrType';\n\nexport class B256Type extends StrType {\n  public static swayType = 'b256';\n\n  public name = 'b256';\n\n  static MATCH_REGEX = /^b256$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return B256Type.MATCH_REGEX.test(params.type);\n  }\n}\n","import { B256Type } from './B256Type';\n\nexport class B512Type extends B256Type {\n  public static swayType = 'struct B512';\n\n  public name = 'b512';\n\n  static MATCH_REGEX = /^struct B512$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return B512Type.MATCH_REGEX.test(params.type);\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { AType } from './AType';\n\nexport class BoolType extends AType implements IType {\n  public static swayType = 'bool';\n\n  public name = 'bool';\n\n  static MATCH_REGEX: RegExp = /^bool$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return BoolType.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    this.attributes = {\n      inputLabel: 'boolean',\n      outputLabel: 'boolean',\n    };\n    return this.attributes;\n  }\n}\n","import type { IRawAbiTypeRoot } from '../types/interfaces/IRawAbiType';\n\nexport function extractStructName(params: { rawAbiType: IRawAbiTypeRoot; regex: RegExp }) {\n  const { rawAbiType, regex } = params;\n\n  const match = rawAbiType.type.match(params.regex)?.[1];\n\n  if (!match) {\n    let errorMessage = `Couldn't extract struct name with: '${regex}'.\\n\\n`;\n    errorMessage += `Check your JSON ABI.\\n\\n[source]\\n`;\n    errorMessage += `${JSON.stringify(rawAbiType, null, 2)}`;\n\n    throw new Error(errorMessage);\n  }\n\n  return match;\n}\n","import type { IRawAbiTypeComponent } from '../../index';\nimport type { TargetEnum } from '../../types/enums/TargetEnum';\nimport type { IType } from '../../types/interfaces/IType';\nimport { extractStructName } from '../../utils/extractStructName';\nimport { findType } from '../../utils/findType';\n\nimport { AType } from './AType';\n\nexport class EnumType extends AType implements IType {\n  public static swayType = 'enum MyEnumName';\n\n  public name = 'enum';\n\n  static MATCH_REGEX: RegExp = /^enum (.+)$/m;\n  static IGNORE_REGEX: RegExp = /^enum Option$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    const isAMatch = EnumType.MATCH_REGEX.test(params.type);\n    const shouldBeIgnored = EnumType.IGNORE_REGEX.test(params.type);\n    return isAMatch && !shouldBeIgnored;\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    const structName = this.getStructName();\n\n    this.attributes = {\n      structName,\n      inputLabel: `${structName}Input`,\n      outputLabel: `${structName}Output`,\n    };\n\n    return this.attributes;\n  }\n\n  public getStructName() {\n    const name = extractStructName({\n      rawAbiType: this.rawAbiType,\n      regex: EnumType.MATCH_REGEX,\n    });\n    return name;\n  }\n\n  public getStructContents(params: { types: IType[]; target: TargetEnum }) {\n    const { types, target } = params;\n\n    const { components } = this.rawAbiType;\n\n    // `components` array guaranteed to always exist for structs/enums\n    const enumComponents = components as IRawAbiTypeComponent[];\n\n    const attributeKey: 'inputLabel' | 'outputLabel' = `${target}Label`;\n\n    const contents = enumComponents.map((component) => {\n      const { name, type: typeId } = component;\n\n      if (typeId === 0) {\n        return `${name}: []`;\n      }\n\n      const { attributes } = findType({ types, typeId });\n      return `${name}: ${attributes[attributeKey]}`;\n    });\n\n    return contents.join(', ');\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\nimport { extractStructName } from '../../utils/extractStructName';\n\nimport { AType } from './AType';\n\nexport class GenericType extends AType implements IType {\n  public static swayType = 'generic T';\n\n  public name = 'generic';\n\n  static MATCH_REGEX: RegExp = /^generic ([^\\s]+)$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return GenericType.MATCH_REGEX.test(params.type);\n  }\n\n  public getStructName() {\n    const name = extractStructName({\n      rawAbiType: this.rawAbiType,\n      regex: GenericType.MATCH_REGEX,\n    });\n    return name;\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    const label = this.getStructName();\n\n    this.attributes = {\n      inputLabel: label,\n      outputLabel: label,\n    };\n\n    return this.attributes;\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { AType } from './AType';\n\nexport class OptionType extends AType implements IType {\n  public static swayType = 'enum Option';\n\n  public name = 'option';\n\n  static MATCH_REGEX: RegExp = /^enum Option$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return OptionType.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    this.attributes = {\n      inputLabel: `Option`,\n      outputLabel: `Option`,\n    };\n    return this.attributes;\n  }\n}\n","import type { IRawAbiTypeRoot } from '../../index';\nimport type { IType } from '../../types/interfaces/IType';\n\nimport { AType } from './AType';\n\nexport class U8Type extends AType implements IType {\n  public static swayType = 'u8';\n\n  public name = 'u8';\n\n  public static MATCH_REGEX: RegExp = /^u8$/m;\n\n  constructor(params: { rawAbiType: IRawAbiTypeRoot }) {\n    super(params);\n    this.attributes = {\n      inputLabel: `BigNumberish`,\n      outputLabel: `number`,\n    };\n    this.requireImportFromFuels = true;\n  }\n\n  static isSuitableFor(params: { type: string }) {\n    return U8Type.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    return this.attributes;\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { U8Type } from './U8Type';\n\nexport class U64Type extends U8Type implements IType {\n  public static swayType = 'u64';\n\n  public name = 'u64';\n\n  public static MATCH_REGEX: RegExp = /^u64$/m;\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    this.attributes = {\n      inputLabel: `BigNumberish`,\n      outputLabel: `BN`,\n    };\n    return this.attributes;\n  }\n\n  static isSuitableFor(params: { type: string }) {\n    return U64Type.MATCH_REGEX.test(params.type);\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { U64Type } from './U64Type';\n\nexport class RawUntypedPtr extends U64Type implements IType {\n  public static swayType = 'raw untyped ptr';\n\n  public name = 'rawUntypedPtr';\n\n  public static MATCH_REGEX: RegExp = /^raw untyped ptr$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return RawUntypedPtr.MATCH_REGEX.test(params.type);\n  }\n}\n","import type { IRawAbiTypeComponent } from '../../index';\nimport type { TargetEnum } from '../../types/enums/TargetEnum';\nimport type { IType } from '../../types/interfaces/IType';\nimport { extractStructName } from '../../utils/extractStructName';\nimport { findType } from '../../utils/findType';\nimport { parseTypeArguments } from '../../utils/parseTypeArguments';\n\nimport { AType } from './AType';\n\nexport class StructType extends AType implements IType {\n  public static swayType = 'struct MyStruct';\n\n  public name = 'struct';\n\n  static MATCH_REGEX: RegExp = /^struct (.+)$/m;\n  static IGNORE_REGEX: RegExp = /^struct (Vec|RawVec)$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    const isAMatch = StructType.MATCH_REGEX.test(params.type);\n    const shouldBeIgnored = StructType.IGNORE_REGEX.test(params.type);\n    return isAMatch && !shouldBeIgnored;\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    const structName = this.getStructName();\n\n    this.attributes = {\n      structName,\n      inputLabel: `${structName}Input`,\n      outputLabel: `${structName}Output`,\n    };\n\n    return this.attributes;\n  }\n\n  public getStructName() {\n    const name = extractStructName({\n      rawAbiType: this.rawAbiType,\n      regex: StructType.MATCH_REGEX,\n    });\n    return name;\n  }\n\n  public getStructContents(params: { types: IType[]; target: TargetEnum }) {\n    const { types, target } = params;\n    const { components } = this.rawAbiType;\n\n    // `components` array guaranteed to always exist for structs/enums\n    const structComponents = components as IRawAbiTypeComponent[];\n\n    // loop through all components\n    const members = structComponents.map((component) => {\n      const { name, type: typeId, typeArguments } = component;\n\n      const type = findType({ types, typeId });\n\n      let typeDecl: string;\n\n      if (typeArguments) {\n        // recursively process child `typeArguments`\n        typeDecl = parseTypeArguments({\n          types,\n          target,\n          parentTypeId: typeId,\n          typeArguments,\n        });\n      } else {\n        // or just collect type declaration\n        const attributeKey: 'inputLabel' | 'outputLabel' = `${target}Label`;\n        typeDecl = type.attributes[attributeKey];\n      }\n\n      // assemble it in `[key: string]: <Type>` fashion\n      return `${name}: ${typeDecl}`;\n    });\n\n    return members.join(', ');\n  }\n\n  public getStructDeclaration(params: { types: IType[] }) {\n    const { types } = params;\n    const { typeParameters } = this.rawAbiType;\n\n    if (typeParameters) {\n      const structs = typeParameters.map((typeId) => findType({ types, typeId }));\n\n      const labels = structs.map(({ attributes: { inputLabel } }) => inputLabel);\n\n      return `<${labels.join(', ')}>`;\n    }\n\n    return '';\n  }\n}\n","import { TargetEnum } from '../../types/enums/TargetEnum';\nimport type { IType } from '../../types/interfaces/IType';\nimport { findType } from '../../utils/findType';\nimport { parseTypeArguments } from '../../utils/parseTypeArguments';\n\nimport { AType } from './AType';\n\nexport class TupleType extends AType implements IType {\n  // Note: a tuple can have more/less than 3x items (like the one bellow)\n  public static swayType = '(_, _, _)';\n\n  public name = 'tupple';\n\n  static MATCH_REGEX: RegExp = /^\\([_,\\s]+\\)$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return TupleType.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(params: { types: IType[] }) {\n    const { types } = params;\n\n    const inputs: string[] = [];\n    const outputs: string[] = [];\n\n    this.rawAbiType.components?.forEach((component) => {\n      const { type: typeId, typeArguments } = component;\n\n      if (!typeArguments) {\n        // if component has no type arguments, read its attributes and voilà\n        const { attributes } = findType({ types, typeId });\n\n        inputs.push(attributes.inputLabel);\n        outputs.push(attributes.outputLabel);\n      } else {\n        // otherwise process child `typeArguments` recursively\n        const inputLabel = parseTypeArguments({\n          types,\n          typeArguments,\n          parentTypeId: typeId,\n          target: TargetEnum.INPUT,\n        });\n\n        const outputLabel = parseTypeArguments({\n          types,\n          typeArguments,\n          parentTypeId: typeId,\n          target: TargetEnum.OUTPUT,\n        });\n\n        inputs.push(inputLabel);\n        outputs.push(outputLabel);\n      }\n    });\n\n    this.attributes = {\n      inputLabel: `[${inputs.join(', ')}]`,\n      outputLabel: `[${outputs.join(', ')}]`,\n    };\n\n    return this.attributes;\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { U8Type } from './U8Type';\n\nexport class U16Type extends U8Type implements IType {\n  public static swayType = 'u16';\n\n  public name = 'u16';\n\n  public static MATCH_REGEX: RegExp = /^u16$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return U16Type.MATCH_REGEX.test(params.type);\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { U8Type } from './U8Type';\n\nexport class U32Type extends U8Type implements IType {\n  public static swayType = 'u32';\n\n  public name = 'u32';\n\n  public static MATCH_REGEX: RegExp = /^u32$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return U32Type.MATCH_REGEX.test(params.type);\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { ArrayType } from './ArrayType';\n\nexport class VectorType extends ArrayType {\n  public static swayType = 'struct Vec';\n\n  public name = 'vector';\n\n  static MATCH_REGEX: RegExp = /^struct Vec/m;\n  static IGNORE_REGEX: RegExp = /^struct RawVec$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    const isAMatch = VectorType.MATCH_REGEX.test(params.type);\n    const shouldBeIgnored = VectorType.IGNORE_REGEX.test(params.type);\n    return isAMatch && !shouldBeIgnored;\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    this.attributes = {\n      inputLabel: `Vec`,\n      outputLabel: `Vec`,\n    };\n    return this.attributes;\n  }\n}\n","import { ArrayType } from '../abi/types/ArrayType';\nimport { B256Type } from '../abi/types/B256Type';\nimport { B512Type } from '../abi/types/B512Type';\nimport { BoolType } from '../abi/types/BoolType';\nimport { EnumType } from '../abi/types/EnumType';\nimport { GenericType } from '../abi/types/GenericType';\nimport { OptionType } from '../abi/types/OptionType';\nimport { RawUntypedPtr } from '../abi/types/RawUntypedPtr';\nimport { StrType } from '../abi/types/StrType';\nimport { StructType } from '../abi/types/StructType';\nimport { TupleType } from '../abi/types/TupleType';\nimport { U16Type } from '../abi/types/U16Type';\nimport { U32Type } from '../abi/types/U32Type';\nimport { U64Type } from '../abi/types/U64Type';\nimport { U8Type } from '../abi/types/U8Type';\nimport { VectorType } from '../abi/types/VectorType';\n\nexport const supportedTypes = [\n  ArrayType,\n  B256Type,\n  B512Type,\n  BoolType,\n  EnumType,\n  GenericType,\n  OptionType,\n  RawUntypedPtr,\n  StrType,\n  StructType,\n  TupleType,\n  U16Type,\n  U32Type,\n  U64Type,\n  U8Type,\n  VectorType,\n];\n","import type { IRawAbiTypeRoot } from '../types/interfaces/IRawAbiType';\n\nimport { supportedTypes } from './supportedTypes';\n\nexport function makeType(params: { rawAbiType: IRawAbiTypeRoot }) {\n  const { rawAbiType } = params;\n  const { type } = rawAbiType;\n\n  const TypeClass = supportedTypes.find((tc) => tc.isSuitableFor({ type }));\n\n  if (!TypeClass) {\n    throw new Error(`Type not supported: ${type}`);\n  }\n\n  return new TypeClass(params);\n}\n","export function shouldSkipAbiType(params: { type: string }) {\n  const ignoreList = ['()', 'struct RawVec'];\n  const shouldSkip = ignoreList.indexOf(params.type) >= 0;\n  return shouldSkip;\n}\n","import type { IRawAbiTypeRoot } from '../types/interfaces/IRawAbiType';\nimport type { IType } from '../types/interfaces/IType';\n\nimport { makeType } from './makeType';\nimport { shouldSkipAbiType } from './shouldSkipAbiType';\n\nexport function parseTypes(params: { rawAbiTypes: IRawAbiTypeRoot[] }) {\n  const types: IType[] = [];\n\n  // First we parse all ROOT nodes\n  params.rawAbiTypes.forEach((rawAbiType) => {\n    const { type } = rawAbiType;\n    const skip = shouldSkipAbiType({ type });\n    if (!skip) {\n      const parsedType = makeType({ rawAbiType });\n      types.push(parsedType);\n    }\n  });\n\n  // Then we parse all thei r components' [attributes]\n  types.forEach((type) => {\n    type.parseComponentsAttributes({ types });\n  });\n\n  return types;\n}\n","import type { ProgramTypeEnum } from '../types/enums/ProgramTypeEnum';\nimport type { IFunction } from '../types/interfaces/IFunction';\nimport type { IRawAbi } from '../types/interfaces/IRawAbi';\nimport type { IType } from '../types/interfaces/IType';\nimport { normalizeName } from '../utils/normalize';\nimport { parseFunctions } from '../utils/parseFunctions';\nimport { parseTypes } from '../utils/parseTypes';\n\n/*\n  Manages many instances of Types and Functions\n*/\nexport class Abi {\n  public name: string;\n  public programType: ProgramTypeEnum;\n\n  public filepath: string;\n  public outputDir: string;\n\n  public commonTypesInUse: string[] = [];\n\n  public rawContents: IRawAbi;\n  public hexlifiedBinContents?: string;\n\n  public types: IType[];\n  public functions: IFunction[];\n\n  constructor(params: {\n    filepath: string;\n    programType: ProgramTypeEnum;\n    rawContents: IRawAbi;\n    hexlifiedBinContents?: string;\n    outputDir: string;\n  }) {\n    const { filepath, outputDir, rawContents, hexlifiedBinContents, programType } = params;\n\n    const abiNameRegex = /([^/]+)-abi\\.json$/m;\n    const abiName = filepath.match(abiNameRegex);\n\n    const couldNotParseName = !abiName || abiName.length === 0;\n\n    if (couldNotParseName) {\n      throw new Error(`Could not parse name from abi file: ${filepath}`);\n    }\n\n    const name = `${normalizeName(abiName[1])}Abi`;\n\n    this.name = name;\n    this.programType = programType;\n\n    this.filepath = filepath;\n    this.rawContents = rawContents;\n    this.hexlifiedBinContents = hexlifiedBinContents;\n    this.outputDir = outputDir;\n\n    const { types, functions } = this.parse();\n\n    this.types = types;\n    this.functions = functions;\n\n    this.computeCommonTypesInUse();\n  }\n\n  parse() {\n    const { types: rawAbiTypes, functions: rawAbiFunctions } = this.rawContents;\n\n    const types = parseTypes({ rawAbiTypes });\n    const functions = parseFunctions({ rawAbiFunctions, types });\n\n    return {\n      types,\n      functions,\n    };\n  }\n\n  computeCommonTypesInUse() {\n    const customTypesTable: Record<string, string> = {\n      option: 'Option',\n      enum: 'Enum',\n      vector: 'Vec',\n    };\n\n    this.commonTypesInUse = [];\n\n    Object.keys(customTypesTable).forEach((typeName) => {\n      const isInUse = !!this.types.find((t) => t.name === typeName);\n\n      if (isInUse) {\n        const commonTypeLabel: string = customTypesTable[typeName];\n        this.commonTypesInUse.push(commonTypeLabel);\n      }\n    });\n  }\n}\n","import { join } from 'path';\n\nimport type { Abi } from '../abi/Abi';\nimport type { IFile } from '../index';\nimport { renderCommonTemplate } from '../templates/common/common';\nimport { renderIndexTemplate } from '../templates/common/index';\nimport { renderDtsTemplate } from '../templates/contract/dts';\nimport { renderFactoryTemplate } from '../templates/contract/factory';\n\n/**\n * Render all Contract-related templates and returns\n * an array of `IFile` with them all. For here on,\n * the only thing missing is to write them to disk.\n */\nexport function assembleContracts(params: { abis: Abi[]; outputDir: string }) {\n  const { abis, outputDir } = params;\n\n  const files: IFile[] = [];\n  const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);\n\n  abis.forEach((abi) => {\n    const { name } = abi;\n\n    const dtsFilepath = `${outputDir}/${name}.d.ts`;\n    const factoryFilepath = `${outputDir}/factories/${name}__factory.ts`;\n\n    const dts: IFile = {\n      path: dtsFilepath,\n      contents: renderDtsTemplate({ abi }),\n    };\n\n    const factory: IFile = {\n      path: factoryFilepath,\n      contents: renderFactoryTemplate({ abi }),\n    };\n\n    files.push(dts);\n    files.push(factory);\n  });\n\n  // Includes index file\n  const indexFile: IFile = {\n    path: `${outputDir}/index.ts`,\n    contents: renderIndexTemplate({ abis }),\n  };\n\n  files.push(indexFile);\n\n  // Conditionally includes `common.d.ts` file if needed\n  if (usesCommonTypes) {\n    const commonsFilepath = join(outputDir, 'common.d.ts');\n    const file: IFile = {\n      path: commonsFilepath,\n      contents: renderCommonTemplate(),\n    };\n    files.push(file);\n  }\n\n  return files;\n}\n","import { versions } from '@fuel-ts/versions';\nimport { compile } from 'handlebars';\n\nimport headerTemplate from './common/_header.hbs';\n\n/*\n  Renders the given template w/ the given data, while injecting common\n  header for disabling lint rules and annotating Fuel component's versions.\n*/\nexport function renderHbsTemplate(params: { template: string; data?: Record<string, unknown> }) {\n  const { data, template } = params;\n\n  const options = {\n    strict: true,\n    noEscape: true,\n  };\n\n  const renderTemplate = compile(template, options);\n  const renderHeaderTemplate = compile(headerTemplate, options);\n\n  const text = renderTemplate({\n    ...data,\n    header: renderHeaderTemplate(versions),\n  });\n\n  return text.replace(/[\\n]{3,}/gm, '\\n\\n');\n}\n","import { renderHbsTemplate } from '../renderHbsTemplate';\n\nimport commonTemplate from './common.hbs';\n\nexport function renderCommonTemplate() {\n  const text = renderHbsTemplate({ template: commonTemplate });\n  return text;\n}\n","import type { Abi } from '../../abi/Abi';\nimport { ProgramTypeEnum } from '../../types/enums/ProgramTypeEnum';\nimport { renderHbsTemplate } from '../renderHbsTemplate';\n\nimport indexTemplate from './index.hbs';\n\nexport function renderIndexTemplate(params: { abis: Abi[] }) {\n  const { abis } = params;\n\n  const isGeneratingContracts = abis[0].programType === ProgramTypeEnum.CONTRACT;\n\n  const text = renderHbsTemplate({\n    template: indexTemplate,\n    data: { abis, isGeneratingContracts },\n  });\n\n  return text;\n}\n","import type { EnumType } from '../../abi/types/EnumType';\nimport { TargetEnum } from '../../types/enums/TargetEnum';\nimport type { IType } from '../../types/interfaces/IType';\n\nexport function formatEnums(params: { types: IType[] }) {\n  const { types } = params;\n\n  const enums = types\n    .filter((t) => t.name === 'enum')\n    .map((t) => {\n      const et = t as EnumType; // only enums here\n      const structName = et.getStructName();\n      const inputValues = et.getStructContents({ types, target: TargetEnum.INPUT });\n      const outputValues = et.getStructContents({ types, target: TargetEnum.OUTPUT });\n      return {\n        structName,\n        inputValues,\n        outputValues,\n        recycleRef: inputValues === outputValues, // reduces duplication\n      };\n    });\n\n  return { enums };\n}\n","import uniq from 'lodash.uniq';\n\nimport type { IType } from '../../types/interfaces/IType';\n\nconst caseInsensitiveSort = (a: string, b: string) =>\n  a.toLowerCase().localeCompare(b.toLowerCase());\n\nexport function formatImports(params: { types: IType[]; baseMembers?: string[] }) {\n  const { types, baseMembers = [] } = params;\n\n  const fuelTypes = types.filter((t) => t.requireImportFromFuels);\n  const members = fuelTypes.map((t) => t.attributes.inputLabel);\n  const imports = uniq(baseMembers.concat(members).sort(caseInsensitiveSort));\n\n  return {\n    imports: imports.length ? imports : undefined,\n  };\n}\n","import type { StructType } from '../../abi/types/StructType';\nimport { TargetEnum } from '../../types/enums/TargetEnum';\nimport type { IType } from '../../types/interfaces/IType';\n\nexport function formatStructs(params: { types: IType[] }) {\n  const { types } = params;\n\n  const structs = types\n    .filter((t) => t.name === 'struct')\n    .map((t) => {\n      const st = t as StructType; // only structs here\n      const structName = st.getStructName();\n      const inputValues = st.getStructContents({ types, target: TargetEnum.INPUT });\n      const outputValues = st.getStructContents({ types, target: TargetEnum.OUTPUT });\n      const typeAnnotations = st.getStructDeclaration({ types });\n      return {\n        structName,\n        typeAnnotations,\n        inputValues,\n        outputValues,\n        recycleRef: inputValues === outputValues, // reduces duplication\n      };\n    });\n\n  return { structs };\n}\n","import type { Abi } from '../../abi/Abi';\nimport { renderHbsTemplate } from '../renderHbsTemplate';\nimport { formatEnums } from '../utils/formatEnums';\nimport { formatImports } from '../utils/formatImports';\nimport { formatStructs } from '../utils/formatStructs';\n\nimport dtsTemplate from './dts.hbs';\n\nexport function renderDtsTemplate(params: { abi: Abi }) {\n  const { name: capitalizedName, types, functions, commonTypesInUse } = params.abi;\n\n  /*\n    First we format all attributes\n  */\n  const functionsTypedefs = functions.map((f) => f.getDeclaration());\n\n  const functionsFragments = functions.map((f) => f.name);\n\n  const encoders = functions.map((f) => ({\n    functionName: f.name,\n    input: f.attributes.inputs,\n  }));\n\n  const decoders = functions.map((f) => ({\n    functionName: f.name,\n  }));\n\n  const { enums } = formatEnums({ types });\n  const { structs } = formatStructs({ types });\n  const { imports } = formatImports({\n    types,\n    baseMembers: [\n      'Interface',\n      'FunctionFragment',\n      'DecodedValue',\n      'Contract',\n      'BytesLike',\n      'InvokeFunction',\n      'BN',\n    ],\n  });\n\n  /*\n    And finally render template\n  */\n  const text = renderHbsTemplate({\n    template: dtsTemplate,\n    data: {\n      capitalizedName,\n      commonTypesInUse: commonTypesInUse.join(', '),\n      functionsTypedefs,\n      functionsFragments,\n      encoders,\n      decoders,\n      structs,\n      enums,\n      imports,\n    },\n  });\n\n  return text;\n}\n","import type { Abi } from '../../abi/Abi';\nimport { renderHbsTemplate } from '../renderHbsTemplate';\n\nimport factoryTemplate from './factory.hbs';\n\nexport function renderFactoryTemplate(params: { abi: Abi }) {\n  const { name: capitalizedName, rawContents } = params.abi;\n  const abiJsonString = JSON.stringify(rawContents, null, 2);\n\n  const text = renderHbsTemplate({\n    template: factoryTemplate,\n    data: { capitalizedName, abiJsonString },\n  });\n\n  return text;\n}\n","import { join } from 'path';\n\nimport type { Abi } from '../abi/Abi';\nimport type { IFile } from '../index';\nimport { renderCommonTemplate } from '../templates/common/common';\nimport { renderIndexTemplate } from '../templates/common/index';\nimport { renderFactoryTemplate } from '../templates/predicate/factory';\n\n/**\n * Render all Predicate-related templates and returns\n * an array of `IFile` with them all. For here on,\n * the only thing missing is to write them to disk.\n */\nexport function assemblePredicates(params: { abis: Abi[]; outputDir: string }) {\n  const { abis, outputDir } = params;\n\n  const files: IFile[] = [];\n  const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);\n\n  abis.forEach((abi) => {\n    const { name } = abi;\n\n    const factoryFilepath = `${outputDir}/factories/${name}__factory.ts`;\n\n    const factory: IFile = {\n      path: factoryFilepath,\n      contents: renderFactoryTemplate({ abi }),\n    };\n\n    files.push(factory);\n  });\n\n  // Includes index file\n  const indexFile: IFile = {\n    path: `${outputDir}/index.ts`,\n    contents: renderIndexTemplate({ abis }),\n  };\n\n  files.push(indexFile);\n\n  // Conditionally includes `common.d.ts` file if needed\n  if (usesCommonTypes) {\n    const commonsFilepath = join(outputDir, 'common.d.ts');\n    const file: IFile = {\n      path: commonsFilepath,\n      contents: renderCommonTemplate(),\n    };\n    files.push(file);\n  }\n\n  return files;\n}\n","import type { Abi } from '../../abi/Abi';\nimport { renderHbsTemplate } from '../renderHbsTemplate';\nimport { formatEnums } from '../utils/formatEnums';\nimport { formatImports } from '../utils/formatImports';\nimport { formatStructs } from '../utils/formatStructs';\n\nimport factoryTemplate from './factory.hbs';\n\nexport function renderFactoryTemplate(params: { abi: Abi }) {\n  const { abi } = params;\n\n  const { types } = abi;\n\n  const {\n    rawContents,\n    name: capitalizedName,\n    hexlifiedBinContents: hexlifiedBinString,\n  } = params.abi;\n\n  const abiJsonString = JSON.stringify(rawContents, null, 2);\n\n  const func = abi.functions.find((f) => f.name === 'main');\n\n  if (!func) {\n    throw new Error(`ABI doesn't have a 'main()' method.`);\n  }\n\n  const { enums } = formatEnums({ types });\n  const { structs } = formatStructs({ types });\n  const { imports } = formatImports({ types, baseMembers: ['Predicate', 'Provider'] });\n\n  const { prefixedInputs: inputs, output } = func.attributes;\n\n  const text = renderHbsTemplate({\n    template: factoryTemplate,\n    data: {\n      inputs,\n      output,\n      structs,\n      enums,\n      abiJsonString,\n      hexlifiedBinString,\n      capitalizedName,\n      imports,\n    },\n  });\n\n  return text;\n}\n","import { join } from 'path';\n\nimport type { Abi } from '../abi/Abi';\nimport type { IFile } from '../index';\nimport { renderCommonTemplate } from '../templates/common/common';\nimport { renderIndexTemplate } from '../templates/common/index';\nimport { renderFactoryTemplate } from '../templates/script/factory';\n\n/**\n * Render all Script-related templates and returns\n * an array of `IFile` with them all. For here on,\n * the only thing missing is to write them to disk.\n */\nexport function assembleScripts(params: { abis: Abi[]; outputDir: string }) {\n  const { abis, outputDir } = params;\n\n  const files: IFile[] = [];\n  const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);\n\n  abis.forEach((abi) => {\n    const { name } = abi;\n\n    const factoryFilepath = `${outputDir}/factories/${name}__factory.ts`;\n\n    const factory: IFile = {\n      path: factoryFilepath,\n      contents: renderFactoryTemplate({ abi }),\n    };\n\n    files.push(factory);\n  });\n\n  // Includes index file\n  const indexFile: IFile = {\n    path: `${outputDir}/index.ts`,\n    contents: renderIndexTemplate({ abis }),\n  };\n\n  files.push(indexFile);\n\n  // Conditionally includes `common.d.ts` file if needed\n  if (usesCommonTypes) {\n    const commonsFilepath = join(outputDir, 'common.d.ts');\n    const file: IFile = {\n      path: commonsFilepath,\n      contents: renderCommonTemplate(),\n    };\n    files.push(file);\n  }\n\n  return files;\n}\n","import type { Abi } from '../../abi/Abi';\nimport { renderHbsTemplate } from '../renderHbsTemplate';\nimport { formatEnums } from '../utils/formatEnums';\nimport { formatImports } from '../utils/formatImports';\nimport { formatStructs } from '../utils/formatStructs';\n\nimport factoryTemplate from './factory.hbs';\n\nexport function renderFactoryTemplate(params: { abi: Abi }) {\n  const { abi } = params;\n\n  const { types } = abi;\n\n  const {\n    rawContents,\n    name: capitalizedName,\n    hexlifiedBinContents: hexlifiedBinString,\n  } = params.abi;\n\n  const abiJsonString = JSON.stringify(rawContents, null, 2);\n\n  const func = abi.functions.find((f) => f.name === 'main');\n\n  if (!func) {\n    throw new Error(`ABI doesn't have a 'main()' method.`);\n  }\n\n  const { enums } = formatEnums({ types });\n  const { structs } = formatStructs({ types });\n  const { imports } = formatImports({ types, baseMembers: ['Script', 'Account'] });\n\n  const { prefixedInputs: inputs, output } = func.attributes;\n\n  const text = renderHbsTemplate({\n    template: factoryTemplate,\n    data: {\n      inputs,\n      output,\n      structs,\n      enums,\n      abiJsonString,\n      hexlifiedBinString,\n      capitalizedName,\n      imports,\n    },\n  });\n\n  return text;\n}\n","import upperFirst from 'lodash.upperfirst';\n\nimport { ProgramTypeEnum } from '../types/enums/ProgramTypeEnum';\n\nexport function validateBinFile(params: {\n  abiFilepath: string;\n  binFilepath: string;\n  binExists: boolean;\n  programType: ProgramTypeEnum;\n}) {\n  const { abiFilepath, binFilepath, binExists, programType } = params;\n\n  const isScript = programType === ProgramTypeEnum.SCRIPT;\n\n  if (!binExists && isScript) {\n    throw new Error(\n      [\n        `Could not find BIN file for counterpart ${upperFirst(programType)} ABI.`,\n        `  - ABI: ${abiFilepath}`,\n        `  - BIN: ${binFilepath}`,\n        programType,\n      ].join('\\n')\n    );\n  }\n}\n","import { Abi } from './abi/Abi';\nimport { ProgramTypeEnum } from './types/enums/ProgramTypeEnum';\nimport type { IFile } from './types/interfaces/IFile';\nimport { assembleContracts } from './utils/assembleContracts';\nimport { assemblePredicates } from './utils/assemblePredicates';\nimport { assembleScripts } from './utils/assembleScripts';\nimport { validateBinFile } from './utils/validateBinFile';\n\n/*\n  Manages many instances of Abi\n*/\nexport class AbiTypeGen {\n  public readonly abis: Abi[];\n  public readonly abiFiles: IFile[];\n  public readonly binFiles: IFile[];\n  public readonly outputDir: string;\n\n  public readonly files: IFile[];\n\n  constructor(params: {\n    abiFiles: IFile[];\n    binFiles: IFile[];\n    outputDir: string;\n    programType: ProgramTypeEnum;\n  }) {\n    const { abiFiles, binFiles, outputDir, programType } = params;\n\n    this.outputDir = outputDir;\n\n    this.abiFiles = abiFiles;\n    this.binFiles = binFiles;\n\n    // Creates a `Abi` for each abi file\n    this.abis = this.abiFiles.map((abiFile) => {\n      const binFilepath = abiFile.path.replace('-abi.json', '.bin');\n      const relatedBinFile = this.binFiles.find(({ path }) => path === binFilepath);\n\n      if (!relatedBinFile) {\n        validateBinFile({\n          abiFilepath: abiFile.path,\n          binExists: !!relatedBinFile,\n          binFilepath,\n          programType,\n        });\n      }\n\n      const abi = new Abi({\n        filepath: abiFile.path,\n        rawContents: JSON.parse(abiFile.contents as string),\n        hexlifiedBinContents: relatedBinFile?.contents,\n        outputDir,\n        programType,\n      });\n\n      return abi;\n    });\n\n    // Assemble list of files to be written to disk\n    this.files = this.getAssembledFiles({ programType });\n  }\n\n  private getAssembledFiles(params: { programType: ProgramTypeEnum }): IFile[] {\n    const { abis, outputDir } = this;\n    const { programType } = params;\n\n    switch (programType) {\n      case ProgramTypeEnum.CONTRACT:\n        return assembleContracts({ abis, outputDir });\n      case ProgramTypeEnum.SCRIPT:\n        return assembleScripts({ abis, outputDir });\n      case ProgramTypeEnum.PREDICATE:\n        return assemblePredicates({ abis, outputDir });\n      default:\n        throw new Error(`Invalid Typegen programType: ${programType}`);\n    }\n  }\n}\n"],"mappings":"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","names":["src_exports","__export","AbiTypeGen","__toCommonJS","import_lodash","normalizeName","rawName","finalName","s","match","upperFirst","t","findType","params","types","typeId","foundType","tid","parseTypeArguments","params","types","typeArguments","parentTypeId","target","attributeKey","buffer","parentType","parentLabel","findType","typeArgument","currentLabel","currentTypeId","nestedParsed","output","Function","params","shouldPrefixParams","types","input","name","typeId","typeArguments","type","findType","typeDecl","parseTypeArguments","prefixedInputs","output","makeFunction","params","types","rawAbiFunction","Function","parseFunctions","params","types","rawAbiFunctions","rawAbiFunction","makeFunction","AType","params","_ArrayType","AType","params","_a","_b","types","type","arrayLen","inputs","outputs","component","typeId","typeArguments","inputLabel","parseTypeArguments","outputLabel","attributes","findType","inputTypes","outputTypes","ArrayType","__publicField","_StrType","AType","params","_params","StrType","__publicField","_B256Type","StrType","params","B256Type","__publicField","_B512Type","B256Type","params","B512Type","__publicField","_BoolType","AType","params","_params","BoolType","__publicField","extractStructName","params","_a","rawAbiType","regex","match","errorMessage","_EnumType","AType","params","isAMatch","shouldBeIgnored","_params","structName","extractStructName","types","target","components","enumComponents","attributeKey","component","name","typeId","attributes","findType","EnumType","__publicField","_GenericType","AType","params","extractStructName","_params","label","GenericType","__publicField","_OptionType","AType","params","_params","OptionType","__publicField","_U8Type","AType","params","_params","U8Type","__publicField","_U64Type","U8Type","_params","params","U64Type","__publicField","_RawUntypedPtr","U64Type","params","RawUntypedPtr","__publicField","_StructType","AType","params","isAMatch","shouldBeIgnored","_params","structName","extractStructName","types","target","components","component","name","typeId","typeArguments","type","findType","typeDecl","parseTypeArguments","attributeKey","typeParameters","inputLabel","StructType","__publicField","_TupleType","AType","params","_a","types","inputs","outputs","component","typeId","typeArguments","inputLabel","parseTypeArguments","outputLabel","attributes","findType","TupleType","__publicField","_U16Type","U8Type","params","U16Type","__publicField","_U32Type","U8Type","params","U32Type","__publicField","_VectorType","ArrayType","params","isAMatch","shouldBeIgnored","_params","VectorType","__publicField","supportedTypes","ArrayType","B256Type","B512Type","BoolType","EnumType","GenericType","OptionType","RawUntypedPtr","StrType","StructType","TupleType","U16Type","U32Type","U64Type","U8Type","VectorType","makeType","params","rawAbiType","type","TypeClass","supportedTypes","tc","shouldSkipAbiType","params","parseTypes","params","types","rawAbiType","type","shouldSkipAbiType","parsedType","makeType","Abi","params","filepath","outputDir","rawContents","hexlifiedBinContents","programType","abiNameRegex","abiName","name","normalizeName","types","functions","rawAbiTypes","rawAbiFunctions","parseTypes","parseFunctions","customTypesTable","typeName","t","commonTypeLabel","import_path","import_versions","import_handlebars","renderHbsTemplate","params","data","template","options","renderTemplate","renderHeaderTemplate","header_default","renderCommonTemplate","renderHbsTemplate","common_default","renderIndexTemplate","params","abis","isGeneratingContracts","renderHbsTemplate","common_default","formatEnums","params","types","t","et","structName","inputValues","outputValues","import_lodash","caseInsensitiveSort","a","b","formatImports","params","types","baseMembers","members","t","imports","uniq","formatStructs","params","types","t","st","structName","inputValues","outputValues","typeAnnotations","renderDtsTemplate","params","capitalizedName","types","functions","commonTypesInUse","functionsTypedefs","f","functionsFragments","encoders","decoders","enums","formatEnums","structs","formatStructs","imports","formatImports","renderHbsTemplate","dts_default","renderFactoryTemplate","params","capitalizedName","rawContents","abiJsonString","renderHbsTemplate","factory_default","assembleContracts","params","abis","outputDir","files","usesCommonTypes","a","abi","name","dtsFilepath","factoryFilepath","dts","renderDtsTemplate","factory","renderFactoryTemplate","indexFile","renderIndexTemplate","file","renderCommonTemplate","import_path","renderFactoryTemplate","params","abi","types","rawContents","capitalizedName","hexlifiedBinString","abiJsonString","func","f","enums","formatEnums","structs","formatStructs","imports","formatImports","inputs","output","renderHbsTemplate","factory_default","assemblePredicates","params","abis","outputDir","files","usesCommonTypes","a","abi","name","factory","renderFactoryTemplate","indexFile","renderIndexTemplate","file","renderCommonTemplate","import_path","renderFactoryTemplate","params","abi","types","rawContents","capitalizedName","hexlifiedBinString","abiJsonString","func","f","enums","formatEnums","structs","formatStructs","imports","formatImports","inputs","output","renderHbsTemplate","factory_default","assembleScripts","params","abis","outputDir","files","usesCommonTypes","a","abi","name","factory","renderFactoryTemplate","indexFile","renderIndexTemplate","file","renderCommonTemplate","import_lodash","validateBinFile","params","abiFilepath","binFilepath","binExists","programType","isScript","upperFirst","AbiTypeGen","params","abiFiles","binFiles","outputDir","programType","abiFile","binFilepath","relatedBinFile","path","validateBinFile","Abi","abis","assembleContracts","assembleScripts","assemblePredicates"]}