{"version":3,"sources":["../src/index.ts","../src/wallet-manager.ts","../src/storages/memory-storage.ts","../src/vaults/mnemonic-vault.ts","../src/vaults/privatekey-vault.ts","../src/types.ts"],"sourcesContent":["export * from './wallet-manager';\nexport * from './types';\n","import type { AbstractAddress } from '@fuel-ts/interfaces';\nimport type { Keystore } from '@fuel-ts/keystore';\nimport { encrypt, decrypt } from '@fuel-ts/keystore';\nimport type { WalletUnlocked } from '@fuel-ts/wallet';\nimport { EventEmitter } from 'events';\n\nimport MemoryStorage from './storages/memory-storage';\nimport type {\n  StorageAbstract,\n  Account,\n  VaultConfig,\n  VaultsState,\n  WalletManagerOptions,\n  WalletManagerState,\n  Vault,\n} from './types';\nimport { MnemonicVault } from './vaults/mnemonic-vault';\nimport { PrivateKeyVault } from './vaults/privatekey-vault';\n\nconst ERROR_MESSAGES = {\n  invalid_vault_type: 'Invalid VaultType',\n  address_not_found: 'Address not found',\n  vault_not_found: 'Vault not found',\n  wallet_not_unlocked: 'Wallet is locked',\n  passphrase_not_match: \"Passphrase didn't match\",\n};\n\n/**\n * Generic assert function to avoid undesirable errors\n */\nfunction assert(condition: unknown, message: string): asserts condition {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\n/**\n * WalletManager is a upper package to manage multiple vaults like mnemonic and privateKeys.\n *\n * - VaultTypes can be add to `WalletManager.Vaults` enabling to add custom Vault types.\n * - Storage can be instantiate when initializing enabling custom storage types.\n */\nexport class WalletManager extends EventEmitter {\n  /**\n   * Vaults\n   *\n   * Vaults are responsible to store secret keys and return an `Wallet` instance,\n   * to interact with the network.\n   *\n   * Each vault has access to its own state\n   *\n   */\n  static Vaults = [MnemonicVault, PrivateKeyVault];\n  /**\n   * Storage\n   *\n   * Persistent encrypted data. `The default storage works only on memory`.\n   */\n  readonly storage: StorageAbstract = new MemoryStorage();\n  /* Key name passed to the storage */\n  readonly STORAGE_KEY: string = 'WalletManager';\n\n  // `This variables are only accessible from inside the class`\n  #vaults: VaultsState = [];\n  #passphrase = '';\n  #isLocked: boolean = true;\n\n  constructor(options?: WalletManagerOptions) {\n    super();\n    this.storage = options?.storage || this.storage;\n  }\n\n  get isLocked(): boolean {\n    return this.#isLocked;\n  }\n\n  /**\n   * Return the vault serialized object containing all the privateKeys,\n   * the format of the return depends on the Vault type.\n   */\n  exportVault<T extends Vault>(vaultId: number): ReturnType<T['serialize']> {\n    assert(!this.#isLocked, ERROR_MESSAGES.wallet_not_unlocked);\n    const vaultState = this.#vaults.find((_, idx) => idx === vaultId);\n    assert(vaultState, ERROR_MESSAGES.vault_not_found);\n    return vaultState.vault.serialize() as ReturnType<T['serialize']>;\n  }\n\n  /**\n   * List all vaults on the Wallet Manager, this function not return secret's\n   */\n  getVaults(): Array<{ title?: string; type: string; vaultId: number }> {\n    return this.#vaults.map((v, idx) => ({\n      title: v.title,\n      type: v.type,\n      vaultId: idx,\n    }));\n  }\n\n  /**\n   * List all accounts on the Wallet Manager not vault information is revealed\n   */\n  getAccounts(): Array<Account> {\n    // Return all accounts from vaults\n    return this.#vaults.flatMap<Account>((vaultState, vaultId) =>\n      vaultState.vault.getAccounts().map((account) => ({ ...account, vaultId }))\n    );\n  }\n\n  /**\n   * Create a Wallet instance for the specific account\n   */\n  getWallet(address: AbstractAddress): WalletUnlocked {\n    const vaultState = this.#vaults.find((vs) =>\n      vs.vault.getAccounts().find((a) => a.address.equals(address))\n    );\n    assert(vaultState, ERROR_MESSAGES.address_not_found);\n\n    return vaultState.vault.getWallet(address);\n  }\n\n  /**\n   * Export specific account privateKey\n   */\n  exportPrivateKey(address: AbstractAddress) {\n    assert(!this.#isLocked, ERROR_MESSAGES.wallet_not_unlocked);\n    const vaultState = this.#vaults.find((vs) =>\n      vs.vault.getAccounts().find((a) => a.address.equals(address))\n    );\n    assert(vaultState, ERROR_MESSAGES.address_not_found);\n\n    return vaultState.vault.exportAccount(address);\n  }\n\n  /**\n   * Add account to a selected vault or on the first vault as default.\n   * If not vaults are adds it will return error\n   */\n  async addAccount(options?: { vaultId: number }) {\n    // Make sure before add new vault state is fully loaded\n    await this.loadState();\n    // Get vault instance\n    const vaultState = this.#vaults[options?.vaultId || 0];\n    await assert(vaultState, ERROR_MESSAGES.vault_not_found);\n    // Add account on vault\n    const account = vaultState.vault.addAccount();\n    // Save the accounts state\n    await this.saveState();\n    // Return account\n    return account;\n  }\n\n  /**\n   * Remove vault by index, by remove the vault you also remove all accounts\n   * created by the vault.\n   */\n  async removeVault(index: number) {\n    this.#vaults.splice(index, 1);\n    await this.saveState();\n  }\n\n  /**\n   * Add Vault, the `vaultConfig.type` will look for the Vaults supported if\n   * didn't found it will throw.\n   */\n  async addVault(vaultConfig: VaultConfig) {\n    // Make sure before add new vault state is fully loaded\n    await this.loadState();\n    // Check if vault is supported\n    const Vault = this.getVaultClass(vaultConfig.type);\n    // create Vault instance\n    const vault = new Vault(vaultConfig);\n    // Push vaults to state\n    this.#vaults = this.#vaults.concat({\n      title: vaultConfig.title,\n      type: vaultConfig.type,\n      vault,\n    });\n    // Persist data on storage\n    await this.saveState();\n  }\n\n  /**\n   * Lock wallet. It removes passphrase from class instance, encrypt and hide all address and\n   * secrets.\n   */\n  async lock() {\n    this.#isLocked = true;\n    // Clean state vaults from state\n    this.#vaults = [];\n    // Clean password from state\n    this.#passphrase = '';\n    // Emit event that wallet is locked\n    await this.emit('lock');\n  }\n\n  /**\n   * Unlock wallet. It sets passphrase on WalletManger instance load all address from configured vaults.\n   * Vaults with secrets are not unlocked or instantiated on this moment.\n   */\n  async unlock(passphrase: string) {\n    // Set password on state\n    this.#passphrase = passphrase;\n    // Set locked state to false\n    this.#isLocked = false;\n    // Try to load state with passphrase\n    try {\n      // Load state with passphrase\n      await this.loadState();\n      // Emit event that wallet is unlocked\n      this.emit('unlock');\n    } catch (err) {\n      // If passphrase is wrong lock wallet\n      await this.lock();\n      // Forward error\n      throw err;\n    }\n  }\n\n  /**\n   * Update WalletManager encryption passphrase\n   */\n  async updatePassphrase(oldpass: string, newpass: string) {\n    const isLocked = this.#isLocked;\n    // Unlock wallet to decrypt data\n    await this.unlock(oldpass);\n    // Set new password on state\n    this.#passphrase = newpass;\n    // Persist data on storage\n    await this.saveState();\n    // Load state with new password\n    await this.loadState();\n    // If wallet was locked, lock the wallet again\n    if (isLocked) {\n      await this.lock();\n    }\n  }\n\n  /**\n   * Retrieve and decrypt WalletManager state from storage\n   */\n  async loadState() {\n    await assert(!this.#isLocked, ERROR_MESSAGES.wallet_not_unlocked);\n\n    const data = await this.storage.getItem(this.STORAGE_KEY);\n    if (data) {\n      const state = await decrypt<WalletManagerState>(this.#passphrase, <Keystore>JSON.parse(data));\n      this.#vaults = this.#deserializeVaults(state.vaults);\n    }\n  }\n\n  /**\n   * Store encrypted WalletManager state on storage\n   */\n  private async saveState() {\n    await assert(!this.#isLocked, ERROR_MESSAGES.wallet_not_unlocked);\n\n    const encryptedData = await encrypt(this.#passphrase, {\n      vaults: this.#serializeVaults(this.#vaults),\n    });\n    await this.storage.setItem(this.STORAGE_KEY, JSON.stringify(encryptedData));\n    this.emit('update');\n  }\n\n  /**\n   * Serialize all vaults to store\n   *\n   * `This is only accessible from inside the class`\n   */\n  #serializeVaults(vaults: VaultsState) {\n    return vaults.map(({ title, type, vault }) => ({\n      title,\n      type,\n      data: vault.serialize(),\n    }));\n  }\n\n  /**\n   * Deserialize all vaults to state\n   *\n   * `This is only accessible from inside the class`\n   */\n  #deserializeVaults(vaults: VaultsState) {\n    return vaults.map(({ title, type, data: vaultConfig }) => {\n      const VaultClass = this.getVaultClass(type);\n      return {\n        title,\n        type,\n        vault: new VaultClass(<VaultConfig>vaultConfig),\n      };\n    });\n  }\n\n  /**\n   * Return a instantiable Class reference from `WalletManager.Vaults` supported list.\n   */\n  private getVaultClass(type: string) {\n    const VaultClass = WalletManager.Vaults.find((v) => v.type === type);\n\n    assert(VaultClass, ERROR_MESSAGES.invalid_vault_type);\n\n    return VaultClass;\n  }\n}\n","import type { StorageAbstract } from '../types';\n\nclass MemoryStorage implements StorageAbstract {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  storage = new Map<string, any>();\n\n  async getItem<T>(key: string): Promise<T | null> {\n    const item = await this.storage.get(key);\n    return item;\n  }\n\n  async setItem(key: string, value: string) {\n    await this.storage.set(key, value);\n  }\n\n  async removeItem(key: string) {\n    await this.storage.delete(key);\n  }\n\n  async clear() {\n    await this.storage.clear();\n  }\n}\n\nexport default MemoryStorage;\n","import type { AbstractAddress } from '@fuel-ts/interfaces';\nimport { Mnemonic } from '@fuel-ts/mnemonic';\nimport type { WalletUnlocked } from '@fuel-ts/wallet';\nimport { Wallet } from '@fuel-ts/wallet';\n\nimport type { Vault } from '../types';\n\ninterface MnemonicVaultOptions {\n  secret?: string;\n  rootPath?: string;\n  numberOfAccounts?: number | null;\n}\n\nexport class MnemonicVault implements Vault<MnemonicVaultOptions> {\n  static readonly type = 'mnemonic';\n  readonly #secret: string;\n\n  pathKey = '{}';\n  rootPath: string = `m/44'/1179993420'/${this.pathKey}'/0/0`;\n  numberOfAccounts: number = 0;\n\n  constructor(options: MnemonicVaultOptions) {\n    this.#secret = options.secret || Mnemonic.generate();\n    this.rootPath = options.rootPath || this.rootPath;\n    // On creating the vault also adds one account\n    this.numberOfAccounts = options.numberOfAccounts || 1;\n  }\n\n  getDerivePath(index: number) {\n    if (this.rootPath.includes(this.pathKey)) {\n      return this.rootPath.replace(this.pathKey, String(index));\n    }\n    return `${this.rootPath}/${index}`;\n  }\n\n  serialize(): MnemonicVaultOptions {\n    return {\n      secret: this.#secret,\n      rootPath: this.rootPath,\n      numberOfAccounts: this.numberOfAccounts,\n    };\n  }\n\n  getAccounts() {\n    const accounts = [];\n    let numberOfAccounts = 0;\n\n    // Create all accounts to current vault\n    do {\n      const wallet = Wallet.fromMnemonic(this.#secret, this.getDerivePath(numberOfAccounts));\n      accounts.push({\n        publicKey: wallet.publicKey,\n        address: wallet.address,\n      });\n      numberOfAccounts += 1;\n    } while (numberOfAccounts < this.numberOfAccounts);\n\n    return accounts;\n  }\n\n  addAccount() {\n    this.numberOfAccounts += 1;\n    const wallet = Wallet.fromMnemonic(this.#secret, this.getDerivePath(this.numberOfAccounts - 1));\n\n    return {\n      publicKey: wallet.publicKey,\n      address: wallet.address,\n    };\n  }\n\n  exportAccount(address: AbstractAddress): string {\n    let numberOfAccounts = 0;\n\n    // Look for the account that has the same address\n    do {\n      const wallet = Wallet.fromMnemonic(this.#secret, this.getDerivePath(numberOfAccounts));\n      if (wallet.address.equals(address)) {\n        return wallet.privateKey;\n      }\n      numberOfAccounts += 1;\n    } while (numberOfAccounts < this.numberOfAccounts);\n\n    throw new Error('Account not found');\n  }\n\n  getWallet(address: AbstractAddress): WalletUnlocked {\n    const privateKey = this.exportAccount(address);\n    return Wallet.fromPrivateKey(privateKey);\n  }\n}\n","import type { AbstractAddress } from '@fuel-ts/interfaces';\nimport type { WalletUnlocked } from '@fuel-ts/wallet';\nimport { Wallet } from '@fuel-ts/wallet';\n\nimport type { Account, Vault } from '../types';\n\ninterface PkVaultOptions {\n  secret?: string;\n  accounts?: Array<string>;\n}\n\nexport class PrivateKeyVault implements Vault<PkVaultOptions> {\n  static readonly type = 'privateKey';\n\n  #privateKeys: Array<string> = [];\n\n  /**\n   * If privateKey vault is initialized with a secretKey, it creates\n   * one account with the fallowing secret\n   */\n  constructor(options: PkVaultOptions) {\n    if (options.secret) {\n      this.#privateKeys = [options.secret];\n    } else {\n      this.#privateKeys = options.accounts || [Wallet.generate().privateKey];\n    }\n  }\n\n  serialize(): PkVaultOptions {\n    return {\n      accounts: this.#privateKeys,\n    };\n  }\n\n  getPublicAccount(privateKey: string) {\n    const wallet = Wallet.fromPrivateKey(privateKey);\n    return {\n      address: wallet.address,\n      publicKey: wallet.publicKey,\n    };\n  }\n\n  getAccounts(): Account[] {\n    return this.#privateKeys.map(this.getPublicAccount);\n  }\n\n  addAccount() {\n    const wallet = Wallet.generate();\n\n    this.#privateKeys.push(wallet.privateKey);\n\n    return this.getPublicAccount(wallet.privateKey);\n  }\n\n  exportAccount(address: AbstractAddress): string {\n    const privateKey = this.#privateKeys.find((pk) =>\n      Wallet.fromPrivateKey(pk).address.equals(address)\n    );\n\n    if (!privateKey) {\n      throw new Error('Address not found');\n    }\n\n    return privateKey;\n  }\n\n  getWallet(address: AbstractAddress): WalletUnlocked {\n    const privateKey = this.exportAccount(address);\n    return Wallet.fromPrivateKey(privateKey);\n  }\n}\n","/* eslint-disable max-classes-per-file */\nimport type { AbstractAddress } from '@fuel-ts/interfaces';\nimport type { WalletUnlocked } from '@fuel-ts/wallet';\n\nexport type Account = {\n  address: AbstractAddress;\n  publicKey: string;\n  vaultId?: number;\n};\n\nexport type WalletManagerOptions = {\n  storage: StorageAbstract;\n};\n\nexport type VaultConfig = {\n  type: string;\n  title?: string;\n  secret?: string;\n};\n\nexport type VaultsState = Array<{\n  type: string;\n  title?: string;\n  data?: VaultConfig;\n  vault: Vault;\n}>;\n\nexport interface WalletManagerState {\n  vaults: VaultsState;\n}\n\nexport abstract class Vault<TOptions = { secret?: string }> {\n  static readonly type: string;\n\n  constructor(_options: TOptions) {\n    throw new Error('Not implemented');\n  }\n\n  serialize(): TOptions {\n    throw new Error('Not implemented');\n  }\n\n  getAccounts(): Account[] {\n    throw new Error('Not implemented');\n  }\n\n  addAccount(): Account {\n    throw new Error('Not implemented');\n  }\n\n  exportAccount(_address: AbstractAddress): string {\n    throw new Error('Not implemented');\n  }\n\n  getWallet(_address: AbstractAddress): WalletUnlocked {\n    throw new Error('Not implemented');\n  }\n}\n\nexport abstract class StorageAbstract {\n  abstract setItem(key: string, value: string): Promise<void>;\n  abstract getItem(key: string): Promise<string | null | undefined>;\n  abstract removeItem(key: string): Promise<void>;\n  abstract clear(): Promise<void>;\n}\n"],"mappings":"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","names":["src_exports","__export","StorageAbstract","Vault","WalletManager","__toCommonJS","import_keystore","import_events","MemoryStorage","key","value","memory_storage_default","import_mnemonic","import_wallet","_secret","MnemonicVault","options","__privateAdd","__publicField","__privateSet","index","__privateGet","accounts","numberOfAccounts","wallet","address","privateKey","import_wallet","_privateKeys","PrivateKeyVault","options","__privateAdd","__privateSet","__privateGet","privateKey","wallet","address","pk","__publicField","ERROR_MESSAGES","assert","condition","message","_vaults","_passphrase","_isLocked","_serializeVaults","serializeVaults_fn","_deserializeVaults","deserializeVaults_fn","_WalletManager","options","__privateAdd","__publicField","memory_storage_default","__privateGet","vaultId","vaultState","_","idx","v","account","address","vs","a","index","vaultConfig","Vault","vault","__privateSet","passphrase","err","oldpass","newpass","isLocked","data","state","__privateMethod","encryptedData","type","VaultClass","WalletManager","vaults","title","MnemonicVault","PrivateKeyVault","Vault","_options","_address","__publicField","StorageAbstract"]}