"use strict";var V=Object.defineProperty;var C=Object.getOwnPropertyDescriptor;var D=Object.getOwnPropertyNames;var q=Object.prototype.hasOwnProperty;var G=(r,e,t)=>e in r?V(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var L=(r,e)=>{for(var t in e)V(r,t,{get:e[t],enumerable:!0})},Y=(r,e,t,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of D(e))!q.call(r,n)&&n!==t&&V(r,n,{get:()=>e[n],enumerable:!(s=C(e,n))||s.enumerable});return r};var $=r=>Y(V({},"__esModule",{value:!0}),r);var l=(r,e,t)=>(G(r,typeof e!="symbol"?e+"":e,t),t),K=(r,e,t)=>{if(!e.has(r))throw TypeError("Cannot "+t)};var a=(r,e,t)=>(K(r,e,"read from private field"),t?t.call(r):e.get(r)),u=(r,e,t)=>{if(e.has(r))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(r):e.set(r,t)},o=(r,e,t,s)=>(K(r,e,"write to private field"),s?s.call(r,t):e.set(r,t),t);var x=(r,e,t)=>(K(r,e,"access private method"),t);var J={};L(J,{StorageAbstract:()=>M,Vault:()=>P,WalletManager:()=>S});module.exports=$(J);var O=require("@fuel-ts/keystore"),z=require("events");var W=class{storage=new Map;async getItem(e){return await this.storage.get(e)}async setItem(e,t){await this.storage.set(e,t)}async removeItem(e){await this.storage.delete(e)}async clear(){await this.storage.clear()}},I=W;var T=require("@fuel-ts/mnemonic"),w=require("@fuel-ts/wallet");var y,v=class{constructor(e){u(this,y,void 0);l(this,"pathKey","{}");l(this,"rootPath",`m/44'/1179993420'/${this.pathKey}'/0/0`);l(this,"numberOfAccounts",0);o(this,y,e.secret||T.Mnemonic.generate()),this.rootPath=e.rootPath||this.rootPath,this.numberOfAccounts=e.numberOfAccounts||1}getDerivePath(e){return this.rootPath.includes(this.pathKey)?this.rootPath.replace(this.pathKey,String(e)):`${this.rootPath}/${e}`}serialize(){return{secret:a(this,y),rootPath:this.rootPath,numberOfAccounts:this.numberOfAccounts}}getAccounts(){let e=[],t=0;do{let s=w.Wallet.fromMnemonic(a(this,y),this.getDerivePath(t));e.push({publicKey:s.publicKey,address:s.address}),t+=1}while(t<this.numberOfAccounts);return e}addAccount(){this.numberOfAccounts+=1;let e=w.Wallet.fromMnemonic(a(this,y),this.getDerivePath(this.numberOfAccounts-1));return{publicKey:e.publicKey,address:e.address}}exportAccount(e){let t=0;do{let s=w.Wallet.fromMnemonic(a(this,y),this.getDerivePath(t));if(s.address.equals(e))return s.privateKey;t+=1}while(t<this.numberOfAccounts);throw new Error("Account not found")}getWallet(e){let t=this.exportAccount(e);return w.Wallet.fromPrivateKey(t)}};y=new WeakMap,l(v,"type","mnemonic");var f=require("@fuel-ts/wallet");var p,b=class{constructor(e){u(this,p,[]);e.secret?o(this,p,[e.secret]):o(this,p,e.accounts||[f.Wallet.generate().privateKey])}serialize(){return{accounts:a(this,p)}}getPublicAccount(e){let t=f.Wallet.fromPrivateKey(e);return{address:t.address,publicKey:t.publicKey}}getAccounts(){return a(this,p).map(this.getPublicAccount)}addAccount(){let e=f.Wallet.generate();return a(this,p).push(e.privateKey),this.getPublicAccount(e.privateKey)}exportAccount(e){let t=a(this,p).find(s=>f.Wallet.fromPrivateKey(s).address.equals(e));if(!t)throw new Error("Address not found");return t}getWallet(e){let t=this.exportAccount(e);return f.Wallet.fromPrivateKey(t)}};p=new WeakMap,l(b,"type","privateKey");var m={invalid_vault_type:"Invalid VaultType",address_not_found:"Address not found",vault_not_found:"Vault not found",wallet_not_unlocked:"Wallet is locked",passphrase_not_match:"Passphrase didn't match"};function h(r,e){if(!r)throw new Error(e)}var i,g,c,_,N,k,R,E=class extends z.EventEmitter{constructor(t){super();u(this,_);u(this,k);l(this,"storage",new I);l(this,"STORAGE_KEY","WalletManager");u(this,i,[]);u(this,g,"");u(this,c,!0);this.storage=(t==null?void 0:t.storage)||this.storage}get isLocked(){return a(this,c)}exportVault(t){h(!a(this,c),m.wallet_not_unlocked);let s=a(this,i).find((n,d)=>d===t);return h(s,m.vault_not_found),s.vault.serialize()}getVaults(){return a(this,i).map((t,s)=>({title:t.title,type:t.type,vaultId:s}))}getAccounts(){return a(this,i).flatMap((t,s)=>t.vault.getAccounts().map(n=>({...n,vaultId:s})))}getWallet(t){let s=a(this,i).find(n=>n.vault.getAccounts().find(d=>d.address.equals(t)));return h(s,m.address_not_found),s.vault.getWallet(t)}exportPrivateKey(t){h(!a(this,c),m.wallet_not_unlocked);let s=a(this,i).find(n=>n.vault.getAccounts().find(d=>d.address.equals(t)));return h(s,m.address_not_found),s.vault.exportAccount(t)}async addAccount(t){await this.loadState();let s=a(this,i)[(t==null?void 0:t.vaultId)||0];await h(s,m.vault_not_found);let n=s.vault.addAccount();return await this.saveState(),n}async removeVault(t){a(this,i).splice(t,1),await this.saveState()}async addVault(t){await this.loadState();let s=this.getVaultClass(t.type),n=new s(t);o(this,i,a(this,i).concat({title:t.title,type:t.type,vault:n})),await this.saveState()}async lock(){o(this,c,!0),o(this,i,[]),o(this,g,""),await this.emit("lock")}async unlock(t){o(this,g,t),o(this,c,!1);try{await this.loadState(),this.emit("unlock")}catch(s){throw await this.lock(),s}}async updatePassphrase(t,s){let n=a(this,c);await this.unlock(t),o(this,g,s),await this.saveState(),await this.loadState(),n&&await this.lock()}async loadState(){await h(!a(this,c),m.wallet_not_unlocked);let t=await this.storage.getItem(this.STORAGE_KEY);if(t){let s=await(0,O.decrypt)(a(this,g),JSON.parse(t));o(this,i,x(this,k,R).call(this,s.vaults))}}async saveState(){await h(!a(this,c),m.wallet_not_unlocked);let t=await(0,O.encrypt)(a(this,g),{vaults:x(this,_,N).call(this,a(this,i))});await this.storage.setItem(this.STORAGE_KEY,JSON.stringify(t)),this.emit("update")}getVaultClass(t){let s=E.Vaults.find(n=>n.type===t);return h(s,m.invalid_vault_type),s}},S=E;i=new WeakMap,g=new WeakMap,c=new WeakMap,_=new WeakSet,N=function(t){return t.map(({title:s,type:n,vault:d})=>({title:s,type:n,data:d.serialize()}))},k=new WeakSet,R=function(t){return t.map(({title:s,type:n,data:d})=>{let U=this.getVaultClass(n);return{title:s,type:n,vault:new U(d)}})},l(S,"Vaults",[v,b]);var P=class{constructor(e){throw new Error("Not implemented")}serialize(){throw new Error("Not implemented")}getAccounts(){throw new Error("Not implemented")}addAccount(){throw new Error("Not implemented")}exportAccount(e){throw new Error("Not implemented")}getWallet(e){throw new Error("Not implemented")}};l(P,"type");var M=class{};0&&(module.exports={StorageAbstract,Vault,WalletManager});
//# sourceMappingURL=index.js.map